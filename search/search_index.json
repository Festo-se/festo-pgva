{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"PGVA","text":"<p><code>festo-pgva</code> is a python package which allows for driver like capabilites and usage over Festo's PGVA-1 device.  </p> <p></p>"},{"location":"#installation","title":"Installation","text":""},{"location":"#from-codebase","title":"From Codebase","text":"<p>Using a terminal interface, navigate to the directory where the code is stored and enter the following command:</p> <pre><code>pip install . -e\n</code></pre> <p>This will make the library locally available as an editable dependency and can be used in Python scripts with <code>import pgva</code></p>"},{"location":"#official-packaged-releases","title":"Official Packaged Releases","text":"<p>The latest released version of this package can be found on the package registry of this project Install using pip:</p> <pre><code>pip install festo-pgva --index-url &lt;private index location with auth key&gt;\n</code></pre>"},{"location":"#from-git-repository","title":"From Git Repository","text":"<p>The festo-pgva source code can also be installed directly from Github. Access the repository here: pgva Github</p> <ol> <li>Clone the repository</li> </ol> <pre><code>git clone https://github.com/Festo-se/festo-pgva.git\n</code></pre> <ol> <li>Navigate to the clone destination directory</li> </ol> <pre><code>cd &lt;destination&gt;\n</code></pre> <ol> <li>Install with pip</li> </ol> <pre><code>pip install . \n</code></pre>"},{"location":"#installation-within-virtual-environment","title":"Installation Within Virtual Environment","text":"<p>To install within a virtual environment, either create one by using the following command</p> <pre><code>python -m venv &lt;virtual environment name&gt; \n</code></pre> <p>Or if one already exists, activate using:</p> <pre><code>&lt;virtual environment name&gt;\\Scripts\\activate.bat\n</code></pre> <p>Once activated, use the instructions from the Release section to install the package</p>"},{"location":"#installation-with-uv-by-astral","title":"Installation With uv By Astral","text":"<p>If your software environment utilizes uv or if you wish to begin using uv for everything python follow the instructions below. If uv is not already installed on the host PC or device, it can be installed following the uv installation guide, or by using pip or pipx. For pip:</p> <pre><code>pip install uv\n</code></pre> <p>For pipx:</p> <pre><code>pipx install uv\n</code></pre> <p>Once uv is installed or if uv is already installed on the host PC or device, use the following command to install the PGVA package into an existing virtual environment.</p> <pre><code>uv pip install festo-pgva\n</code></pre> <p>To add the festo-pgva library to an existing project</p> <pre><code>uv add festo-pgva\n</code></pre>"},{"location":"#pymodbus-dependency","title":"Pymodbus Dependency","text":"<p>The <code>festo-pgva</code> library uses the <code>pymodbus</code> library as its core communication dependency for both TCP/IP and Serial connections. To gain a better understanding of the fundamentals of PyModbus, please visit PyModbus Homepage, or for a more in-depth reading, please visit PyModbus readthedocs. PyPI package information for PyModbus can also be found here.</p>"},{"location":"autoapi/summary/","title":"Summary","text":"<ul> <li>pgva<ul> <li>_constants</li> <li>pgva</li> <li>pgva_communication</li> <li>pgva_config</li> <li>pgva_interface</li> <li>registers</li> </ul> </li> </ul>"},{"location":"autoapi/pgva/","title":"pgva","text":""},{"location":"autoapi/pgva/#pgva.PGVA","title":"<code>PGVA</code>","text":"<p>PGVA driver class.</p> <p>This is the main class that the user will interact with to control the PGVA-1 device.</p> Source code in <code>src/pgva/pgva.py</code> <pre><code>class PGVA:\n    \"\"\"\n    PGVA driver class.\n\n    This is the main class that the user will interact with\n    to control the PGVA-1 device.\n    \"\"\"\n\n    _backend: PGVAModbusClient\n\n    def __init__(self, config: PGVAConfig):\n        \"\"\"\n        PGVA driver class constructor.\n\n        Args:\n            config (PGVAConfig): A ModbusTCP or ModbusSerial config\n                    type to allow the driver to connect to the\n                    correct communication interface\n\n        Returns:\n            None\n\n        Raises:\n            NotImplementedError: If a serial configuration is passed through PGVA.\n            TypeError: If config is not a supported PGVAConfig type for this driver.\n        \"\"\"\n        if isinstance(config, PGVAConfig):\n            self._config = config\n            match config:\n                case PGVASerialConfig():\n                    logger.error(\"\"\"\n                        Serial support for PGVA communication is currently experimental.\n                        The serial connected can be tested explicitly by instantiating PGVAModbusSerial and passing in the communication backend explicitly.\n                    \"\"\")\n                    raise NotImplementedError(\"Serial communication is experimental and must be invoked directly\")\n                    self._backend = PGVAModbusSerial(config=self._config)\n                    logger.debug(\"PGVA front-end initialised with serial backend\")\n                case PGVATCPConfig():\n                    self._backend = PGVAModbusTCP(config=self._config)\n                    logger.debug(\"PGVA front-end initialised with TCP backend\")\n        else:\n            logger.error(\"Unsupported configuration type passed to PGVA: %s\", type(config).__name__)\n            raise TypeError(\"Error, configuration passed in is not supported by driver\")\n\n    def set_output_pressure(self, pressure: int) -&gt; None:\n        \"\"\"\n        Sets the output pressure to PGVA.\n\n        Args:\n            pressure (int): Pressure in mBar between -450 ... 450\n\n        Returns:\n            None\n        \"\"\"\n        self._backend.set_output_pressure(pressure)\n\n    def trigger_actuation_valve(self, actuation_time: int) -&gt; None:\n        \"\"\"\n        Opens the actuation valve for a certain amount of time.\n\n        Args:\n            actuation_time (int): Time in milliseconds\n\n        Returns:\n            None\n        \"\"\"\n        self._backend.set_actuation_time(actuation_time=actuation_time)\n\n    def set_pressure_chamber(self, pressure: int) -&gt; None:\n        \"\"\"\n        Sets the internal pressure chamber.\n\n        Args:\n            pressure (int): Range between 0 and 450 mBar\n\n        Returns:\n            None\n        \"\"\"\n        self._backend.set_pressure_chamber(pressure)\n\n    def set_vacuum_chamber(self, vacuum: int) -&gt; None:\n        \"\"\"\n        Sets the internal vacuum chamber.\n\n        Args:\n            vacuum (int): Range between -450 and 0 mBar\n\n        Returns:\n            None\n        \"\"\"\n        self._backend.set_vacuum_chamber(vacuum)\n\n    def get_pressure_chamber(self) -&gt; int:\n        \"\"\"\n        Returns the current reading of the pressure chamber in mBar.\n\n        Args:\n            None\n\n        Returns:\n            Pressure chamber pressure in mBar\n        \"\"\"\n        return self._backend.get_pressure_chamber()\n\n    def get_vacuum_chamber(self) -&gt; int:\n        \"\"\"\n        Returns the current reading of the vacuum chamber in mBar.\n\n        Args:\n            None\n\n        Returns:\n            Vacuum chamber pressure in mBar\n        \"\"\"\n        return self._backend.get_vacuum_chamber()\n\n    def get_output_pressure(self) -&gt; int:\n        \"\"\"\n        Returns the output port pressure in mBar.\n\n        Args:\n            None\n\n        Returns:\n            Positive or negative pressure in mBar\n        \"\"\"\n        return self._backend.get_output_pressure()\n\n    def get_internal_sensor_data(self) -&gt; dict:\n        \"\"\"\n        Returns all the internal sensor data in mBar.\n\n        Args:\n            None\n\n        Returns:\n            All current readings of internal sensors\n        \"\"\"\n        return self._backend.get_internal_sensor_data()\n\n    def toggle_pump(self, toggle: bool) -&gt; None:\n        \"\"\"\n        Enable / Disables the pump.\n\n        Args:\n            toggle (bool): 1 for on, 0 for off\n\n        Returns:\n            None\n        \"\"\"\n        self._backend.toggle_pump(toggle)\n\n    def get_status_word(self) -&gt; dict:\n        \"\"\"\n        Gets the status word from the PGVA.\n\n        Args:\n            None\n\n        Returns:\n           Dictionary of the status word\n        \"\"\"\n        return self._backend.get_status_word()\n\n    def get_warning_word(self) -&gt; dict:\n        \"\"\"\n        Gets the warning word from the PGVA-1.\n\n        Args:\n            None\n\n        Returns:\n            Dictionary of warning word\n        \"\"\"\n        return self._backend.get_warning_word()\n\n    def get_error_word(self) -&gt; dict:\n        \"\"\"\n        Gets the error word from the PGVA-1.\n\n        Args:\n            None\n\n        Returns:\n            Dictionary of error word\n        \"\"\"\n        return self._backend.get_error_word()\n\n    def get_modbus_error_word(self) -&gt; dict:\n        \"\"\"\n        Get the error word from the PGVA-1.\n\n        Args:\n            None\n\n        Returns:\n            Dictionary of modbus error word\n        \"\"\"\n        return self._backend.get_modbus_error_word()\n\n    def toggle_trigger(self, trigger: bool) -&gt; None:\n        \"\"\"\n        Toggles the trigger.\n\n        Args:\n            trigger (bool): bool value for on or off\n\n        Returns:\n            None\n        \"\"\"\n        self._backend.toggle_manual_trigger(trigger)\n\n    def print_driver_information(self) -&gt; None:\n        \"\"\"\n        Prints driver information to console.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n        self._backend.print_driver_information()\n</code></pre>"},{"location":"autoapi/pgva/#pgva.PGVA.__init__","title":"<code>__init__(config)</code>","text":"<p>PGVA driver class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>PGVAConfig</code> <p>A ModbusTCP or ModbusSerial config     type to allow the driver to connect to the     correct communication interface</p> required <p>Returns:</p> Type Description <p>None</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If a serial configuration is passed through PGVA.</p> <code>TypeError</code> <p>If config is not a supported PGVAConfig type for this driver.</p> Source code in <code>src/pgva/pgva.py</code> <pre><code>def __init__(self, config: PGVAConfig):\n    \"\"\"\n    PGVA driver class constructor.\n\n    Args:\n        config (PGVAConfig): A ModbusTCP or ModbusSerial config\n                type to allow the driver to connect to the\n                correct communication interface\n\n    Returns:\n        None\n\n    Raises:\n        NotImplementedError: If a serial configuration is passed through PGVA.\n        TypeError: If config is not a supported PGVAConfig type for this driver.\n    \"\"\"\n    if isinstance(config, PGVAConfig):\n        self._config = config\n        match config:\n            case PGVASerialConfig():\n                logger.error(\"\"\"\n                    Serial support for PGVA communication is currently experimental.\n                    The serial connected can be tested explicitly by instantiating PGVAModbusSerial and passing in the communication backend explicitly.\n                \"\"\")\n                raise NotImplementedError(\"Serial communication is experimental and must be invoked directly\")\n                self._backend = PGVAModbusSerial(config=self._config)\n                logger.debug(\"PGVA front-end initialised with serial backend\")\n            case PGVATCPConfig():\n                self._backend = PGVAModbusTCP(config=self._config)\n                logger.debug(\"PGVA front-end initialised with TCP backend\")\n    else:\n        logger.error(\"Unsupported configuration type passed to PGVA: %s\", type(config).__name__)\n        raise TypeError(\"Error, configuration passed in is not supported by driver\")\n</code></pre>"},{"location":"autoapi/pgva/#pgva.PGVA.get_error_word","title":"<code>get_error_word()</code>","text":"<p>Gets the error word from the PGVA-1.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary of error word</p> Source code in <code>src/pgva/pgva.py</code> <pre><code>def get_error_word(self) -&gt; dict:\n    \"\"\"\n    Gets the error word from the PGVA-1.\n\n    Args:\n        None\n\n    Returns:\n        Dictionary of error word\n    \"\"\"\n    return self._backend.get_error_word()\n</code></pre>"},{"location":"autoapi/pgva/#pgva.PGVA.get_internal_sensor_data","title":"<code>get_internal_sensor_data()</code>","text":"<p>Returns all the internal sensor data in mBar.</p> <p>Returns:</p> Type Description <code>dict</code> <p>All current readings of internal sensors</p> Source code in <code>src/pgva/pgva.py</code> <pre><code>def get_internal_sensor_data(self) -&gt; dict:\n    \"\"\"\n    Returns all the internal sensor data in mBar.\n\n    Args:\n        None\n\n    Returns:\n        All current readings of internal sensors\n    \"\"\"\n    return self._backend.get_internal_sensor_data()\n</code></pre>"},{"location":"autoapi/pgva/#pgva.PGVA.get_modbus_error_word","title":"<code>get_modbus_error_word()</code>","text":"<p>Get the error word from the PGVA-1.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary of modbus error word</p> Source code in <code>src/pgva/pgva.py</code> <pre><code>def get_modbus_error_word(self) -&gt; dict:\n    \"\"\"\n    Get the error word from the PGVA-1.\n\n    Args:\n        None\n\n    Returns:\n        Dictionary of modbus error word\n    \"\"\"\n    return self._backend.get_modbus_error_word()\n</code></pre>"},{"location":"autoapi/pgva/#pgva.PGVA.get_output_pressure","title":"<code>get_output_pressure()</code>","text":"<p>Returns the output port pressure in mBar.</p> <p>Returns:</p> Type Description <code>int</code> <p>Positive or negative pressure in mBar</p> Source code in <code>src/pgva/pgva.py</code> <pre><code>def get_output_pressure(self) -&gt; int:\n    \"\"\"\n    Returns the output port pressure in mBar.\n\n    Args:\n        None\n\n    Returns:\n        Positive or negative pressure in mBar\n    \"\"\"\n    return self._backend.get_output_pressure()\n</code></pre>"},{"location":"autoapi/pgva/#pgva.PGVA.get_pressure_chamber","title":"<code>get_pressure_chamber()</code>","text":"<p>Returns the current reading of the pressure chamber in mBar.</p> <p>Returns:</p> Type Description <code>int</code> <p>Pressure chamber pressure in mBar</p> Source code in <code>src/pgva/pgva.py</code> <pre><code>def get_pressure_chamber(self) -&gt; int:\n    \"\"\"\n    Returns the current reading of the pressure chamber in mBar.\n\n    Args:\n        None\n\n    Returns:\n        Pressure chamber pressure in mBar\n    \"\"\"\n    return self._backend.get_pressure_chamber()\n</code></pre>"},{"location":"autoapi/pgva/#pgva.PGVA.get_status_word","title":"<code>get_status_word()</code>","text":"<p>Gets the status word from the PGVA.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary of the status word</p> Source code in <code>src/pgva/pgva.py</code> <pre><code>def get_status_word(self) -&gt; dict:\n    \"\"\"\n    Gets the status word from the PGVA.\n\n    Args:\n        None\n\n    Returns:\n       Dictionary of the status word\n    \"\"\"\n    return self._backend.get_status_word()\n</code></pre>"},{"location":"autoapi/pgva/#pgva.PGVA.get_vacuum_chamber","title":"<code>get_vacuum_chamber()</code>","text":"<p>Returns the current reading of the vacuum chamber in mBar.</p> <p>Returns:</p> Type Description <code>int</code> <p>Vacuum chamber pressure in mBar</p> Source code in <code>src/pgva/pgva.py</code> <pre><code>def get_vacuum_chamber(self) -&gt; int:\n    \"\"\"\n    Returns the current reading of the vacuum chamber in mBar.\n\n    Args:\n        None\n\n    Returns:\n        Vacuum chamber pressure in mBar\n    \"\"\"\n    return self._backend.get_vacuum_chamber()\n</code></pre>"},{"location":"autoapi/pgva/#pgva.PGVA.get_warning_word","title":"<code>get_warning_word()</code>","text":"<p>Gets the warning word from the PGVA-1.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary of warning word</p> Source code in <code>src/pgva/pgva.py</code> <pre><code>def get_warning_word(self) -&gt; dict:\n    \"\"\"\n    Gets the warning word from the PGVA-1.\n\n    Args:\n        None\n\n    Returns:\n        Dictionary of warning word\n    \"\"\"\n    return self._backend.get_warning_word()\n</code></pre>"},{"location":"autoapi/pgva/#pgva.PGVA.print_driver_information","title":"<code>print_driver_information()</code>","text":"<p>Prints driver information to console.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/pgva/pgva.py</code> <pre><code>def print_driver_information(self) -&gt; None:\n    \"\"\"\n    Prints driver information to console.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    self._backend.print_driver_information()\n</code></pre>"},{"location":"autoapi/pgva/#pgva.PGVA.set_output_pressure","title":"<code>set_output_pressure(pressure)</code>","text":"<p>Sets the output pressure to PGVA.</p> <p>Parameters:</p> Name Type Description Default <code>pressure</code> <code>int</code> <p>Pressure in mBar between -450 ... 450</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/pgva/pgva.py</code> <pre><code>def set_output_pressure(self, pressure: int) -&gt; None:\n    \"\"\"\n    Sets the output pressure to PGVA.\n\n    Args:\n        pressure (int): Pressure in mBar between -450 ... 450\n\n    Returns:\n        None\n    \"\"\"\n    self._backend.set_output_pressure(pressure)\n</code></pre>"},{"location":"autoapi/pgva/#pgva.PGVA.set_pressure_chamber","title":"<code>set_pressure_chamber(pressure)</code>","text":"<p>Sets the internal pressure chamber.</p> <p>Parameters:</p> Name Type Description Default <code>pressure</code> <code>int</code> <p>Range between 0 and 450 mBar</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/pgva/pgva.py</code> <pre><code>def set_pressure_chamber(self, pressure: int) -&gt; None:\n    \"\"\"\n    Sets the internal pressure chamber.\n\n    Args:\n        pressure (int): Range between 0 and 450 mBar\n\n    Returns:\n        None\n    \"\"\"\n    self._backend.set_pressure_chamber(pressure)\n</code></pre>"},{"location":"autoapi/pgva/#pgva.PGVA.set_vacuum_chamber","title":"<code>set_vacuum_chamber(vacuum)</code>","text":"<p>Sets the internal vacuum chamber.</p> <p>Parameters:</p> Name Type Description Default <code>vacuum</code> <code>int</code> <p>Range between -450 and 0 mBar</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/pgva/pgva.py</code> <pre><code>def set_vacuum_chamber(self, vacuum: int) -&gt; None:\n    \"\"\"\n    Sets the internal vacuum chamber.\n\n    Args:\n        vacuum (int): Range between -450 and 0 mBar\n\n    Returns:\n        None\n    \"\"\"\n    self._backend.set_vacuum_chamber(vacuum)\n</code></pre>"},{"location":"autoapi/pgva/#pgva.PGVA.toggle_pump","title":"<code>toggle_pump(toggle)</code>","text":"<p>Enable / Disables the pump.</p> <p>Parameters:</p> Name Type Description Default <code>toggle</code> <code>bool</code> <p>1 for on, 0 for off</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/pgva/pgva.py</code> <pre><code>def toggle_pump(self, toggle: bool) -&gt; None:\n    \"\"\"\n    Enable / Disables the pump.\n\n    Args:\n        toggle (bool): 1 for on, 0 for off\n\n    Returns:\n        None\n    \"\"\"\n    self._backend.toggle_pump(toggle)\n</code></pre>"},{"location":"autoapi/pgva/#pgva.PGVA.toggle_trigger","title":"<code>toggle_trigger(trigger)</code>","text":"<p>Toggles the trigger.</p> <p>Parameters:</p> Name Type Description Default <code>trigger</code> <code>bool</code> <p>bool value for on or off</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/pgva/pgva.py</code> <pre><code>def toggle_trigger(self, trigger: bool) -&gt; None:\n    \"\"\"\n    Toggles the trigger.\n\n    Args:\n        trigger (bool): bool value for on or off\n\n    Returns:\n        None\n    \"\"\"\n    self._backend.toggle_manual_trigger(trigger)\n</code></pre>"},{"location":"autoapi/pgva/#pgva.PGVA.trigger_actuation_valve","title":"<code>trigger_actuation_valve(actuation_time)</code>","text":"<p>Opens the actuation valve for a certain amount of time.</p> <p>Parameters:</p> Name Type Description Default <code>actuation_time</code> <code>int</code> <p>Time in milliseconds</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/pgva/pgva.py</code> <pre><code>def trigger_actuation_valve(self, actuation_time: int) -&gt; None:\n    \"\"\"\n    Opens the actuation valve for a certain amount of time.\n\n    Args:\n        actuation_time (int): Time in milliseconds\n\n    Returns:\n        None\n    \"\"\"\n    self._backend.set_actuation_time(actuation_time=actuation_time)\n</code></pre>"},{"location":"autoapi/pgva/#pgva.PGVASerialConfig","title":"<code>PGVASerialConfig</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PGVAConfig</code></p> <p>Class PGVA-1 configuration for serial connection.</p> <p>Attributes:</p> Name Type Description <code>com_port</code> <code>str</code> <p>COM port of the serial connection. Ex: 'COM3' or '/dev/ttyUSB0'</p> <code>baudrate</code> <code>int</code> <p>Baudrate of the serial connection. Ex: 9600, 19200, 115200</p> Source code in <code>src/pgva/pgva_config.py</code> <pre><code>@dataclass(kw_only=True)\nclass PGVASerialConfig(PGVAConfig):\n    \"\"\"\n    Class PGVA-1 configuration for serial connection.\n\n    Attributes:\n        com_port (str): COM port of the serial connection. Ex: 'COM3' or '/dev/ttyUSB0'\n        baudrate (int): Baudrate of the serial connection. Ex: 9600, 19200, 115200\n    \"\"\"\n\n    com_port: str\n    baudrate: int\n</code></pre>"},{"location":"autoapi/pgva/#pgva.PGVATCPConfig","title":"<code>PGVATCPConfig</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PGVAConfig</code></p> <p>Class for PGVA-1 configuration class for ModbusTCP connection.</p> <p>Attributes:</p> Name Type Description <code>ip</code> <code>str</code> <p>IP address of PGVA in string form. Ex: '192.168.0.1'</p> <code>port</code> <code>int</code> <p>Default to 502, port of connunication for the PGVA-1</p> Source code in <code>src/pgva/pgva_config.py</code> <pre><code>@dataclass(kw_only=True)\nclass PGVATCPConfig(PGVAConfig):\n    \"\"\"\n    Class for PGVA-1 configuration class for ModbusTCP connection.\n\n    Attributes:\n        ip (str): IP address of PGVA in string form. Ex: '192.168.0.1'\n        port (int): Default to 502, port of connunication for the PGVA-1\n    \"\"\"\n\n    ip: str\n    port: int = 502\n</code></pre>"},{"location":"autoapi/pgva/_constants/","title":"_constants","text":"<p>Internal hardware limit constants for the PGVA-1 device.</p> <p>These values are derived from the PGVA-1 operation manual and are used internally by the driver. They are not part of the public API.</p>"},{"location":"autoapi/pgva/pgva/","title":"pgva","text":"<p>PGVA interface Front end.</p> <p>Unified driver front-end exposing standard PGVA control API for both ModbusSerial and ModbusTCP  communication clients</p>"},{"location":"autoapi/pgva/pgva/#pgva.pgva.PGVA","title":"<code>PGVA</code>","text":"<p>PGVA driver class.</p> <p>This is the main class that the user will interact with to control the PGVA-1 device.</p> Source code in <code>src/pgva/pgva.py</code> <pre><code>class PGVA:\n    \"\"\"\n    PGVA driver class.\n\n    This is the main class that the user will interact with\n    to control the PGVA-1 device.\n    \"\"\"\n\n    _backend: PGVAModbusClient\n\n    def __init__(self, config: PGVAConfig):\n        \"\"\"\n        PGVA driver class constructor.\n\n        Args:\n            config (PGVAConfig): A ModbusTCP or ModbusSerial config\n                    type to allow the driver to connect to the\n                    correct communication interface\n\n        Returns:\n            None\n\n        Raises:\n            NotImplementedError: If a serial configuration is passed through PGVA.\n            TypeError: If config is not a supported PGVAConfig type for this driver.\n        \"\"\"\n        if isinstance(config, PGVAConfig):\n            self._config = config\n            match config:\n                case PGVASerialConfig():\n                    logger.error(\"\"\"\n                        Serial support for PGVA communication is currently experimental.\n                        The serial connected can be tested explicitly by instantiating PGVAModbusSerial and passing in the communication backend explicitly.\n                    \"\"\")\n                    raise NotImplementedError(\"Serial communication is experimental and must be invoked directly\")\n                    self._backend = PGVAModbusSerial(config=self._config)\n                    logger.debug(\"PGVA front-end initialised with serial backend\")\n                case PGVATCPConfig():\n                    self._backend = PGVAModbusTCP(config=self._config)\n                    logger.debug(\"PGVA front-end initialised with TCP backend\")\n        else:\n            logger.error(\"Unsupported configuration type passed to PGVA: %s\", type(config).__name__)\n            raise TypeError(\"Error, configuration passed in is not supported by driver\")\n\n    def set_output_pressure(self, pressure: int) -&gt; None:\n        \"\"\"\n        Sets the output pressure to PGVA.\n\n        Args:\n            pressure (int): Pressure in mBar between -450 ... 450\n\n        Returns:\n            None\n        \"\"\"\n        self._backend.set_output_pressure(pressure)\n\n    def trigger_actuation_valve(self, actuation_time: int) -&gt; None:\n        \"\"\"\n        Opens the actuation valve for a certain amount of time.\n\n        Args:\n            actuation_time (int): Time in milliseconds\n\n        Returns:\n            None\n        \"\"\"\n        self._backend.set_actuation_time(actuation_time=actuation_time)\n\n    def set_pressure_chamber(self, pressure: int) -&gt; None:\n        \"\"\"\n        Sets the internal pressure chamber.\n\n        Args:\n            pressure (int): Range between 0 and 450 mBar\n\n        Returns:\n            None\n        \"\"\"\n        self._backend.set_pressure_chamber(pressure)\n\n    def set_vacuum_chamber(self, vacuum: int) -&gt; None:\n        \"\"\"\n        Sets the internal vacuum chamber.\n\n        Args:\n            vacuum (int): Range between -450 and 0 mBar\n\n        Returns:\n            None\n        \"\"\"\n        self._backend.set_vacuum_chamber(vacuum)\n\n    def get_pressure_chamber(self) -&gt; int:\n        \"\"\"\n        Returns the current reading of the pressure chamber in mBar.\n\n        Args:\n            None\n\n        Returns:\n            Pressure chamber pressure in mBar\n        \"\"\"\n        return self._backend.get_pressure_chamber()\n\n    def get_vacuum_chamber(self) -&gt; int:\n        \"\"\"\n        Returns the current reading of the vacuum chamber in mBar.\n\n        Args:\n            None\n\n        Returns:\n            Vacuum chamber pressure in mBar\n        \"\"\"\n        return self._backend.get_vacuum_chamber()\n\n    def get_output_pressure(self) -&gt; int:\n        \"\"\"\n        Returns the output port pressure in mBar.\n\n        Args:\n            None\n\n        Returns:\n            Positive or negative pressure in mBar\n        \"\"\"\n        return self._backend.get_output_pressure()\n\n    def get_internal_sensor_data(self) -&gt; dict:\n        \"\"\"\n        Returns all the internal sensor data in mBar.\n\n        Args:\n            None\n\n        Returns:\n            All current readings of internal sensors\n        \"\"\"\n        return self._backend.get_internal_sensor_data()\n\n    def toggle_pump(self, toggle: bool) -&gt; None:\n        \"\"\"\n        Enable / Disables the pump.\n\n        Args:\n            toggle (bool): 1 for on, 0 for off\n\n        Returns:\n            None\n        \"\"\"\n        self._backend.toggle_pump(toggle)\n\n    def get_status_word(self) -&gt; dict:\n        \"\"\"\n        Gets the status word from the PGVA.\n\n        Args:\n            None\n\n        Returns:\n           Dictionary of the status word\n        \"\"\"\n        return self._backend.get_status_word()\n\n    def get_warning_word(self) -&gt; dict:\n        \"\"\"\n        Gets the warning word from the PGVA-1.\n\n        Args:\n            None\n\n        Returns:\n            Dictionary of warning word\n        \"\"\"\n        return self._backend.get_warning_word()\n\n    def get_error_word(self) -&gt; dict:\n        \"\"\"\n        Gets the error word from the PGVA-1.\n\n        Args:\n            None\n\n        Returns:\n            Dictionary of error word\n        \"\"\"\n        return self._backend.get_error_word()\n\n    def get_modbus_error_word(self) -&gt; dict:\n        \"\"\"\n        Get the error word from the PGVA-1.\n\n        Args:\n            None\n\n        Returns:\n            Dictionary of modbus error word\n        \"\"\"\n        return self._backend.get_modbus_error_word()\n\n    def toggle_trigger(self, trigger: bool) -&gt; None:\n        \"\"\"\n        Toggles the trigger.\n\n        Args:\n            trigger (bool): bool value for on or off\n\n        Returns:\n            None\n        \"\"\"\n        self._backend.toggle_manual_trigger(trigger)\n\n    def print_driver_information(self) -&gt; None:\n        \"\"\"\n        Prints driver information to console.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n        self._backend.print_driver_information()\n</code></pre>"},{"location":"autoapi/pgva/pgva/#pgva.pgva.PGVA.__init__","title":"<code>__init__(config)</code>","text":"<p>PGVA driver class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>PGVAConfig</code> <p>A ModbusTCP or ModbusSerial config     type to allow the driver to connect to the     correct communication interface</p> required <p>Returns:</p> Type Description <p>None</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If a serial configuration is passed through PGVA.</p> <code>TypeError</code> <p>If config is not a supported PGVAConfig type for this driver.</p> Source code in <code>src/pgva/pgva.py</code> <pre><code>def __init__(self, config: PGVAConfig):\n    \"\"\"\n    PGVA driver class constructor.\n\n    Args:\n        config (PGVAConfig): A ModbusTCP or ModbusSerial config\n                type to allow the driver to connect to the\n                correct communication interface\n\n    Returns:\n        None\n\n    Raises:\n        NotImplementedError: If a serial configuration is passed through PGVA.\n        TypeError: If config is not a supported PGVAConfig type for this driver.\n    \"\"\"\n    if isinstance(config, PGVAConfig):\n        self._config = config\n        match config:\n            case PGVASerialConfig():\n                logger.error(\"\"\"\n                    Serial support for PGVA communication is currently experimental.\n                    The serial connected can be tested explicitly by instantiating PGVAModbusSerial and passing in the communication backend explicitly.\n                \"\"\")\n                raise NotImplementedError(\"Serial communication is experimental and must be invoked directly\")\n                self._backend = PGVAModbusSerial(config=self._config)\n                logger.debug(\"PGVA front-end initialised with serial backend\")\n            case PGVATCPConfig():\n                self._backend = PGVAModbusTCP(config=self._config)\n                logger.debug(\"PGVA front-end initialised with TCP backend\")\n    else:\n        logger.error(\"Unsupported configuration type passed to PGVA: %s\", type(config).__name__)\n        raise TypeError(\"Error, configuration passed in is not supported by driver\")\n</code></pre>"},{"location":"autoapi/pgva/pgva/#pgva.pgva.PGVA.get_error_word","title":"<code>get_error_word()</code>","text":"<p>Gets the error word from the PGVA-1.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary of error word</p> Source code in <code>src/pgva/pgva.py</code> <pre><code>def get_error_word(self) -&gt; dict:\n    \"\"\"\n    Gets the error word from the PGVA-1.\n\n    Args:\n        None\n\n    Returns:\n        Dictionary of error word\n    \"\"\"\n    return self._backend.get_error_word()\n</code></pre>"},{"location":"autoapi/pgva/pgva/#pgva.pgva.PGVA.get_internal_sensor_data","title":"<code>get_internal_sensor_data()</code>","text":"<p>Returns all the internal sensor data in mBar.</p> <p>Returns:</p> Type Description <code>dict</code> <p>All current readings of internal sensors</p> Source code in <code>src/pgva/pgva.py</code> <pre><code>def get_internal_sensor_data(self) -&gt; dict:\n    \"\"\"\n    Returns all the internal sensor data in mBar.\n\n    Args:\n        None\n\n    Returns:\n        All current readings of internal sensors\n    \"\"\"\n    return self._backend.get_internal_sensor_data()\n</code></pre>"},{"location":"autoapi/pgva/pgva/#pgva.pgva.PGVA.get_modbus_error_word","title":"<code>get_modbus_error_word()</code>","text":"<p>Get the error word from the PGVA-1.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary of modbus error word</p> Source code in <code>src/pgva/pgva.py</code> <pre><code>def get_modbus_error_word(self) -&gt; dict:\n    \"\"\"\n    Get the error word from the PGVA-1.\n\n    Args:\n        None\n\n    Returns:\n        Dictionary of modbus error word\n    \"\"\"\n    return self._backend.get_modbus_error_word()\n</code></pre>"},{"location":"autoapi/pgva/pgva/#pgva.pgva.PGVA.get_output_pressure","title":"<code>get_output_pressure()</code>","text":"<p>Returns the output port pressure in mBar.</p> <p>Returns:</p> Type Description <code>int</code> <p>Positive or negative pressure in mBar</p> Source code in <code>src/pgva/pgva.py</code> <pre><code>def get_output_pressure(self) -&gt; int:\n    \"\"\"\n    Returns the output port pressure in mBar.\n\n    Args:\n        None\n\n    Returns:\n        Positive or negative pressure in mBar\n    \"\"\"\n    return self._backend.get_output_pressure()\n</code></pre>"},{"location":"autoapi/pgva/pgva/#pgva.pgva.PGVA.get_pressure_chamber","title":"<code>get_pressure_chamber()</code>","text":"<p>Returns the current reading of the pressure chamber in mBar.</p> <p>Returns:</p> Type Description <code>int</code> <p>Pressure chamber pressure in mBar</p> Source code in <code>src/pgva/pgva.py</code> <pre><code>def get_pressure_chamber(self) -&gt; int:\n    \"\"\"\n    Returns the current reading of the pressure chamber in mBar.\n\n    Args:\n        None\n\n    Returns:\n        Pressure chamber pressure in mBar\n    \"\"\"\n    return self._backend.get_pressure_chamber()\n</code></pre>"},{"location":"autoapi/pgva/pgva/#pgva.pgva.PGVA.get_status_word","title":"<code>get_status_word()</code>","text":"<p>Gets the status word from the PGVA.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary of the status word</p> Source code in <code>src/pgva/pgva.py</code> <pre><code>def get_status_word(self) -&gt; dict:\n    \"\"\"\n    Gets the status word from the PGVA.\n\n    Args:\n        None\n\n    Returns:\n       Dictionary of the status word\n    \"\"\"\n    return self._backend.get_status_word()\n</code></pre>"},{"location":"autoapi/pgva/pgva/#pgva.pgva.PGVA.get_vacuum_chamber","title":"<code>get_vacuum_chamber()</code>","text":"<p>Returns the current reading of the vacuum chamber in mBar.</p> <p>Returns:</p> Type Description <code>int</code> <p>Vacuum chamber pressure in mBar</p> Source code in <code>src/pgva/pgva.py</code> <pre><code>def get_vacuum_chamber(self) -&gt; int:\n    \"\"\"\n    Returns the current reading of the vacuum chamber in mBar.\n\n    Args:\n        None\n\n    Returns:\n        Vacuum chamber pressure in mBar\n    \"\"\"\n    return self._backend.get_vacuum_chamber()\n</code></pre>"},{"location":"autoapi/pgva/pgva/#pgva.pgva.PGVA.get_warning_word","title":"<code>get_warning_word()</code>","text":"<p>Gets the warning word from the PGVA-1.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary of warning word</p> Source code in <code>src/pgva/pgva.py</code> <pre><code>def get_warning_word(self) -&gt; dict:\n    \"\"\"\n    Gets the warning word from the PGVA-1.\n\n    Args:\n        None\n\n    Returns:\n        Dictionary of warning word\n    \"\"\"\n    return self._backend.get_warning_word()\n</code></pre>"},{"location":"autoapi/pgva/pgva/#pgva.pgva.PGVA.print_driver_information","title":"<code>print_driver_information()</code>","text":"<p>Prints driver information to console.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/pgva/pgva.py</code> <pre><code>def print_driver_information(self) -&gt; None:\n    \"\"\"\n    Prints driver information to console.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    self._backend.print_driver_information()\n</code></pre>"},{"location":"autoapi/pgva/pgva/#pgva.pgva.PGVA.set_output_pressure","title":"<code>set_output_pressure(pressure)</code>","text":"<p>Sets the output pressure to PGVA.</p> <p>Parameters:</p> Name Type Description Default <code>pressure</code> <code>int</code> <p>Pressure in mBar between -450 ... 450</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/pgva/pgva.py</code> <pre><code>def set_output_pressure(self, pressure: int) -&gt; None:\n    \"\"\"\n    Sets the output pressure to PGVA.\n\n    Args:\n        pressure (int): Pressure in mBar between -450 ... 450\n\n    Returns:\n        None\n    \"\"\"\n    self._backend.set_output_pressure(pressure)\n</code></pre>"},{"location":"autoapi/pgva/pgva/#pgva.pgva.PGVA.set_pressure_chamber","title":"<code>set_pressure_chamber(pressure)</code>","text":"<p>Sets the internal pressure chamber.</p> <p>Parameters:</p> Name Type Description Default <code>pressure</code> <code>int</code> <p>Range between 0 and 450 mBar</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/pgva/pgva.py</code> <pre><code>def set_pressure_chamber(self, pressure: int) -&gt; None:\n    \"\"\"\n    Sets the internal pressure chamber.\n\n    Args:\n        pressure (int): Range between 0 and 450 mBar\n\n    Returns:\n        None\n    \"\"\"\n    self._backend.set_pressure_chamber(pressure)\n</code></pre>"},{"location":"autoapi/pgva/pgva/#pgva.pgva.PGVA.set_vacuum_chamber","title":"<code>set_vacuum_chamber(vacuum)</code>","text":"<p>Sets the internal vacuum chamber.</p> <p>Parameters:</p> Name Type Description Default <code>vacuum</code> <code>int</code> <p>Range between -450 and 0 mBar</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/pgva/pgva.py</code> <pre><code>def set_vacuum_chamber(self, vacuum: int) -&gt; None:\n    \"\"\"\n    Sets the internal vacuum chamber.\n\n    Args:\n        vacuum (int): Range between -450 and 0 mBar\n\n    Returns:\n        None\n    \"\"\"\n    self._backend.set_vacuum_chamber(vacuum)\n</code></pre>"},{"location":"autoapi/pgva/pgva/#pgva.pgva.PGVA.toggle_pump","title":"<code>toggle_pump(toggle)</code>","text":"<p>Enable / Disables the pump.</p> <p>Parameters:</p> Name Type Description Default <code>toggle</code> <code>bool</code> <p>1 for on, 0 for off</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/pgva/pgva.py</code> <pre><code>def toggle_pump(self, toggle: bool) -&gt; None:\n    \"\"\"\n    Enable / Disables the pump.\n\n    Args:\n        toggle (bool): 1 for on, 0 for off\n\n    Returns:\n        None\n    \"\"\"\n    self._backend.toggle_pump(toggle)\n</code></pre>"},{"location":"autoapi/pgva/pgva/#pgva.pgva.PGVA.toggle_trigger","title":"<code>toggle_trigger(trigger)</code>","text":"<p>Toggles the trigger.</p> <p>Parameters:</p> Name Type Description Default <code>trigger</code> <code>bool</code> <p>bool value for on or off</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/pgva/pgva.py</code> <pre><code>def toggle_trigger(self, trigger: bool) -&gt; None:\n    \"\"\"\n    Toggles the trigger.\n\n    Args:\n        trigger (bool): bool value for on or off\n\n    Returns:\n        None\n    \"\"\"\n    self._backend.toggle_manual_trigger(trigger)\n</code></pre>"},{"location":"autoapi/pgva/pgva/#pgva.pgva.PGVA.trigger_actuation_valve","title":"<code>trigger_actuation_valve(actuation_time)</code>","text":"<p>Opens the actuation valve for a certain amount of time.</p> <p>Parameters:</p> Name Type Description Default <code>actuation_time</code> <code>int</code> <p>Time in milliseconds</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/pgva/pgva.py</code> <pre><code>def trigger_actuation_valve(self, actuation_time: int) -&gt; None:\n    \"\"\"\n    Opens the actuation valve for a certain amount of time.\n\n    Args:\n        actuation_time (int): Time in milliseconds\n\n    Returns:\n        None\n    \"\"\"\n    self._backend.set_actuation_time(actuation_time=actuation_time)\n</code></pre>"},{"location":"autoapi/pgva/pgva_communication/","title":"pgva_communication","text":"<p>PGVA-1 communication backend module.</p> <p>PGVA driver communication backend implementation. PGVA driver can use two different modes of communication to control the device, ModbusSerial and ModbusTCP. These are implemented here.</p>"},{"location":"autoapi/pgva/pgva_communication/#pgva.pgva_communication.PGVAModbusClient","title":"<code>PGVAModbusClient</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Modbus Client Class.</p> Source code in <code>src/pgva/pgva_communication.py</code> <pre><code>class PGVAModbusClient(ABC):\n    \"\"\"Modbus Client Class.\"\"\"\n\n    client: ModbusTcpClient | ModbusSerialClient\n    version: list\n    _pgva_error: dict\n    _modbus_error: dict\n    _warning: dict\n    _status: dict\n\n    @abstractmethod\n    def __init__(self, config):\n        \"\"\"Base abstract class init, ModbusTCP and ModbusSerial will have their own implemenation.\"\"\"\n        self._config = config\n\n    def get_firmware_version(self) -&gt; list:\n        \"\"\"Gets the current firmware version located on the PGVA.\n\n        Args:\n            None\n\n        Returns:\n            List of the version\n        \"\"\"\n        self.version = []\n        if len(self.version) &lt; 3:\n            self.version.append(self._get_data(commands.FIRMWARE_VERSION))\n            self.version.append(self._get_data(commands.FIRMWARE_SUBVERSION))\n            self.version.append(self._get_data(commands.FIRMWARE_BUILD))\n            logger.debug(\"Firmware version retrieved: %s\", self.version)\n            return self.version\n        return [0, 0, 0]\n\n    def _get_data(self, register):\n        \"\"\"\n        Method used to access data from a register.\n\n        Args:\n            register: Register address for data access\n\n        Returns:\n            value: Value from register\n        \"\"\"\n        logger.debug(\"Reading input register: %s\", str(register))\n        try:\n            data = self.client.read_input_registers(\n                address=int(register.value),\n                count=1,\n            )\n            return data.registers[0]\n        except ModbusException as modbus_pdu_exception:\n            logger.error(\"Error while reading : %s\", str(modbus_pdu_exception))\n            return None\n        except TypeError as type_err:\n            logger.error(\"Error while reading: %s\", str(type_err))\n            return None\n\n    def _get_data_holding(self, register):\n        \"\"\"Method used to read the holding registers.\"\"\"\n        data = 0\n        logger.debug(\"Reading holding register: %s\", str(register))\n        try:\n            data = self.client.read_holding_registers(\n                address=int(register.value),\n                count=1,\n            )\n            return data.registers[0]\n        except ModbusException as modbus_pdu_exception:\n            logger.error(\"Error while reading holding: %s\", str(modbus_pdu_exception))\n            return None\n        except TypeError as type_err:\n            logger.error(\"Error while reading holding: %s\", str(type_err))\n            return None\n\n    def _set_data(self, register, val, timeout: float = 30.0):\n        \"\"\"\n        Method used to write to registers.\n\n        Args:\n            register: Register address for accessing\n            val: Value to be written to register\n            timeout (float): Maximum seconds to wait for the device to leave\n                the busy state after the write. Defaults to 30 seconds.\n\n        Raises:\n            TimeoutError: If the device remains busy beyond ``timeout`` seconds.\n        \"\"\"\n        logger.debug(\"Writing register %s, value: %s\", str(register), str(val))\n        try:\n            if val &lt; 0:\n                val = val + 2**16\n            self.client.write_register(\n                address=int(register.value),\n                value=val,\n            )\n            deadline = time.monotonic() + timeout\n            status = self.client.read_input_registers(\n                address=int(commands.STATUS_WORD.value),\n                count=1,\n            )\n            while (status.registers[0] &amp; 1) == 1:\n                if time.monotonic() &gt; deadline:\n                    logger.error(\n                        \"Device still busy after %.1f s following write to %s \u2014 aborting poll\",\n                        timeout,\n                        str(register),\n                    )\n                    raise TimeoutError(\n                        f\"PGVA device remained busy for more than {timeout}s after writing to {register}\"\n                    )\n                status = self.client.read_input_registers(\n                    address=int(commands.STATUS_WORD.value),\n                    count=1,\n                )\n        except ModbusException as modbus_pdu_exception:\n            logger.error(\"Modbus Exception Error : %s\", str(modbus_pdu_exception))\n        except TypeError as type_err:\n            logger.error(\"Type error while writing data: %s\", str(type_err))\n\n    def set_output_pressure(self, pressure: int) -&gt; None:\n        \"\"\"\n        Sets the output pressure for the PGVA.\n\n        Args:\n            pressure (int): Any range between -450 ... 450\n\n        Returns:\n            None\n\n        Raises:\n            ValueError: If pressure is outside the supported output pressure range.\n        \"\"\"\n        if self._validate_pump_enable():\n            if consts.MINIMUM_OUTPUT_PRESSURE_MBAR &lt;= pressure &lt;= consts.MAXIMUM_OUTPUT_PRESSURE_MBAR:\n                logger.info(\"Setting output pressure to %s mBar\", pressure)\n                self._set_data(commands.OUTPUT_PRESSURE_MBAR, pressure)\n            else:\n                logger.error(\"Input pressure outside of working range: %s\", str(pressure))\n                raise ValueError(\"Input pressure outside of working range\")\n\n    def set_actuation_time(self, actuation_time: int) -&gt; None:\n        \"\"\"\n        Sets the valve actuation time which is then immediately executed.\n\n        Args:\n            actuation_time (int): Time in ms for valve to be open\n\n        Returns:\n            None\n\n        Raises:\n            ValueError: If actuation_time is outside the valid range of 5 to 65535 ms.\n        \"\"\"\n        if actuation_time in range(5, 65535):\n            logger.info(\"Triggering actuation valve for %s ms\", actuation_time)\n            self._set_data(commands.VALVE_ACTUATION_TIME, actuation_time)\n            # time.sleep(actuation_time / 1000)\n        else:\n            logger.error(\n                \"Error: acuation time out of range (5, 65535), inputted: %s\",\n                str(actuation_time),\n            )\n            raise ValueError(\"Error: Value entered for actuation time needs to be between 5 and 65535\")\n\n    def toggle_manual_trigger(self, toggle: bool) -&gt; None:\n        \"\"\"\n        Toggles the manual trigger to either on or off.\n\n        Args:\n            toggle (int): Bool value, 1 for on, 0 for off\n\n        Returns:\n            None\n\n        Raises:\n            NotImplementedError: Manual trigger is not implemented due to a firmware limitation.\n        \"\"\"\n        # self._set_data(commands.MANUAL_TRIGGER, int(toggle))\n        logger.warning(\"toggle_manual_trigger() is not implemented: known firmware bug in PGVA-1 firmware &lt;= 2.0.45\")\n        raise NotImplementedError(\"\"\"\n                                  Manual trigger not implemented. There is a bug that exists in the PGVA-1 firmware &lt;=2.0.45\n                                  that prevents this function from working as intended\n                                  \"\"\")\n\n    def get_internal_sensor_data(self) -&gt; dict:\n        \"\"\"\n        Reads the internal Vacuum and Pressure chambers as well as the output pressure sensor.\n\n        Args:\n            None\n\n        Returns:\n            Dictionary of the sensor values\n        \"\"\"\n        status = {}\n        if self.version[0:3] != [2, 1, 3]:\n            status[\"Extsensor\"] = self._get_data(commands.EXTERNAL_SENSOR_VALUE)\n        status[\"VacuumChamber\"] = self.get_vacuum_chamber()\n        status[\"PressureChamber\"] = self.get_pressure_chamber()\n        status[\"OutputPressure\"] = self.get_output_pressure()\n        logger.debug(\"Internal sensor data: %s\", status)\n        return status\n\n    def get_vacuum_chamber(self) -&gt; int:\n        \"\"\"\n        Reads the internal vacuum chamber pressure.\n\n        Args:\n            None\n\n        Returns:\n            Vacuum chamber pressure in mBar\n        \"\"\"\n        vacuum = self._get_data(commands.VACUUM_ACTUAL_MBAR)\n        result = self._convert_twos_comp(vacuum, len(bin(vacuum)[2:]))\n        logger.debug(\"Vacuum chamber reading: %s mBar\", result)\n        return result\n\n    def get_pressure_chamber(self) -&gt; int:\n        \"\"\"\n        Reads the internal pressure chamber pressure.\n\n        Args:\n            None\n\n        Returns:\n            Pressure chamber pressure in mBar\n        \"\"\"\n        result = self._get_data(commands.PRESSURE_ACTUAL_MBAR)\n        logger.debug(\"Pressure chamber reading: %s mBar\", result)\n        return result\n\n    def get_output_pressure(self) -&gt; int:\n        \"\"\"\n        Reads the output port pressure.\n\n        Args:\n            None\n\n        Returns:\n            Output pressure in mBar\n        \"\"\"\n        pressure = self._get_data(commands.OUTPUT_PRESSURE_ACTUAL_MBAR)\n        if pressure &gt; 500:\n            result = self._convert_twos_comp(pressure, len(bin(pressure)[2:]))\n            logger.debug(\"Output pressure reading: %s mBar\", result)\n            return result\n        logger.debug(\"Output pressure reading: %s mBar\", pressure)\n        return pressure\n\n    def set_pressure_chamber(self, pressure: int) -&gt; None:\n        \"\"\"\n        Sets the internal pressure chamber.\n\n        Args:\n            pressure (int): Range between 200 ... 1000 mBar\n\n        Returns:\n            None\n\n        Raises:\n            ValueError: If pressure is outside the supported pressure chamber range.\n        \"\"\"\n        if consts.MINIMUM_PRESSURE_CHAMBER_MBAR &lt;= pressure &lt;= consts.MAXIMUM_PRESSURE_CHAMBER_MBAR:\n            # Using the pressure scaling factor provided via operation manual of the PGVA\n            logger.info(\"Setting pressure chamber to %s mBar\", pressure)\n            pressure = int(pressure * consts.PRESSURE_CHAMBER_CONVERSION_FACTOR)\n            self._set_data(commands.PRESSURE_THRESHOLD, pressure)\n        else:\n            err = f\"Error: {pressure} input pressure outside of PGVA-1 working conditions. Please enter a value between 200 and 1000 mBar.\"\n            logger.error(err)\n            raise ValueError(err)\n\n    def set_vacuum_chamber(self, vacuum: int) -&gt; None:\n        \"\"\"\n        Sets the internal vacuum chamber.\n\n        Args:\n            vacuum (int): Range between -200 ... -620 mBar\n\n        Returns:\n            None\n\n        Raises:\n            ValueError: If vacuum is outside the supported vacuum chamber range.\n        \"\"\"\n        if consts.MINIMUM_VACUUM_CHAMBER_MBAR &lt;= vacuum &lt;= consts.MAXIMUM_VACUUM_CHAMBER_MBAR:\n            logger.info(\"Setting vacuum chamber to %s mBar\", vacuum)\n            vacuum = int(vacuum * consts.VACUUM_CHAMBER_CONVERSION_FACTOR)\n            self._set_data(commands.VACUUM_THRESHOLD, vacuum)\n        else:\n            err = f\"Error: {vacuum} input pressure outside of PGVA-1 working conditions.\"\n            logger.error(err)\n            raise ValueError(err)\n\n    def toggle_pump(self, toggle: bool) -&gt; None:\n        \"\"\"\n        Enables or disables the pump for creating pressure / vacuum.\n\n        Args:\n            toggle (bool): 1 for on, 0 for off\n\n        Returns:\n            None\n        \"\"\"\n        logger.info(\"Toggling pump: %s\", \"ON\" if toggle else \"OFF\")\n        if self.version[0:3] != [2, 1, 3]:\n            self._set_data(commands.PUMP_ENABLE, toggle)\n        else:\n            logger.info(\"PGVA firmware does not support the enable/disable pump function\")\n\n    def _validate_pump_enable(self):\n        \"\"\"\n        Validates that the pump is enabled for creating pressure.\n\n        Args:\n            None\n\n        Returns:\n            Bool: True if enabled, False if disabled\n        \"\"\"\n        if self.version[0:3] != [2, 1, 3]:\n            if self._get_data_holding(commands.PUMP_ENABLE) == 1:\n                logger.debug(\"Pump validation: pump is enabled\")\n                return True\n            logger.warning(\"Pump is NOT enabled \u2014 call toggle_pump(True) before setting pressure\")\n            return False\n        logger.info(\"PGVA firmware version does not support the enable/disable pump function\")\n        return True\n\n    def _enable_pump(self):\n        \"\"\"\n        Enables the pump.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n        if self.version[0:3] != [2, 1, 3]:\n            logger.info(\"Enabling pump\")\n            self._set_data(commands.PUMP_ENABLE, 1)\n        else:\n            logger.info(\"PGVA firmware does not support the enable/disable pump function\")\n\n    def _disable_pump(self):\n        \"\"\"\n        Disables the pump.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n        if self.version[0:3] != [2, 1, 3]:\n            logger.info(\"Disabling pump\")\n            self._set_data(commands.PUMP_ENABLE, 0)\n        else:\n            logger.info(\"connected PGVA device version does not support this function \")\n\n    def print_driver_information(self) -&gt; None:\n        \"\"\"\n        Logs all driver parameters at INFO level.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n        internal_data = self.get_internal_sensor_data()\n        logger.info(\"Driver Information:\")\n        logger.info(\"  Firmware version: %s\", self.version)\n        logger.info(\"  Connection type: %s\", self._config.interface)\n        logger.info(\"  Sensor data: %s\", internal_data)\n\n    def get_status_word(self) -&gt; dict:\n        \"\"\"\n        Reads the status word and outputs it to the log.\n\n        Args:\n            None\n\n        Returns:\n            Current status of the PGVA-1\n        \"\"\"\n        pgva_status = self._get_data(commands.STATUS_WORD)\n        status_word = {\n            \"Status\": self._status[\"Status\"][pgva_status &amp; 1],\n            \"Pump\": self._status[\"Pump\"][(pgva_status &gt;&gt; 1) &amp; 0b11],\n            \"Pressure\": self._status[\"Pressure\"][(pgva_status &gt;&gt; 3) &amp; 1],\n            \"Vacuum\": self._status[\"Vacuum\"][(pgva_status &gt;&gt; 4) &amp; 1],\n            \"EEPROM\": self._status[\"EEPROM\"][(pgva_status &gt;&gt; 5) &amp; 1],\n            \"TargetPressure\": self._status[\"TargetPressure\"][(pgva_status &gt;&gt; 6) &amp; 1],\n            \"Trigger\": self._status[\"Trigger\"][(pgva_status &gt;&gt; 7) &amp; 1],\n            \"OutputValveControl\": self._status[\"OutputValveControl\"][(pgva_status &gt;&gt; 10) &amp; 1],\n            \"OutputValve\": self._status[\"OutputValve\"][(pgva_status &gt;&gt; 11) &amp; 1],\n        }\n\n        logger.debug(\"Status word: %s\", status_word)\n        return status_word\n\n    def get_warning_word(self) -&gt; dict:\n        \"\"\"\n        Reads the warning word and outputs it to the log.\n\n        Args:\n            None\n\n        Returns:\n           Current warning word of the PGVA-1\n        \"\"\"\n        pgva_warning = self._get_data(commands.WARNING_WORD)\n        warning_word = {\n            \"SupplyVoltage\": self._warning[\"SupplyVoltage\"][pgva_warning &amp; 1],\n            \"VacuumThreshold\": self._warning[\"VacuumThreshold\"][(pgva_warning &gt;&gt; 1) &amp; 1],\n            \"PressureThreshold\": self._warning[\"PressureThreshold\"][(pgva_warning &gt;&gt; 2) &amp; 1],\n            \"TargetPressure\": self._warning[\"TargetPressure\"][(pgva_warning &gt;&gt; 4) &amp; 1],\n            \"VacuumChamber\": self._warning[\"VacuumChamber\"][(pgva_warning &gt;&gt; 5) &amp; 1],\n            \"Pump\": self._warning[\"Pump\"][(pgva_warning &gt;&gt; 7) &amp; 1],\n            \"ExternalSensor\": self._warning[\"ExternalSensor\"][(pgva_warning &gt;&gt; 9) &amp; 1],\n        }\n        if any(v != \"Reset\" for v in warning_word.values()):\n            logger.warning(\"Active PGVA warning(s): %s\", warning_word)\n        else:\n            logger.debug(\"Warning word: %s\", warning_word)\n        return warning_word\n\n    def get_error_word(self) -&gt; dict:\n        \"\"\"\n        Reads the error word and outputs it to the log.\n\n        Args:\n            None\n\n        Returns:\n            Current error word of the PGVA-1\n        \"\"\"\n        pgva_error = self._get_data(commands.ERROR_WORD)\n        error_word = {\n            \"PumpTimeout\": self._pgva_error[\"PumpTimeout\"][pgva_error &amp; 1],\n            \"TimeoutPressure\": self._pgva_error[\"TimeoutPressure\"][(pgva_error &gt;&gt; 1) &amp; 1],\n            \"ModbusError\": self._pgva_error[\"ModbusError\"][(pgva_error &gt;&gt; 2) &amp; 1],\n            \"LowVoltage\": self._pgva_error[\"LowVoltage\"][(pgva_error &gt;&gt; 3) &amp; 1],\n            \"HighVoltage\": self._pgva_error[\"HighVoltage\"][(pgva_error &gt;&gt; 4) &amp; 1],\n            \"TimeoutExternalSensor\": self._pgva_error[\"TimeoutExternalSensor\"][(pgva_error &gt;&gt; 5) &amp; 1],\n        }\n        if any(v != \"Reset\" for v in error_word.values()):\n            logger.error(\"Active PGVA error(s): %s\", error_word)\n        else:\n            logger.debug(\"Error word: %s\", error_word)\n        return error_word\n\n    def get_modbus_error_word(self) -&gt; dict:\n        \"\"\"\n        Reads the modbus error word and outputs it to the log.\n\n        Args:\n            None\n\n        Returns:\n            Current modbus error word of the PGVA-1\n        \"\"\"\n        modbus_error = self._get_data(commands.LAST_MODBUS_ERROR)\n        modbus_error_word = {\"OutputActuationTime\": self._modbus_error[\"OutputActuationTime\"][modbus_error &amp; 1]}\n        if any(v != \"Reset\" for v in modbus_error_word.values()):\n            logger.error(\"Active Modbus error(s): %s\", modbus_error_word)\n        else:\n            logger.debug(\"Modbus error word: %s\", modbus_error_word)\n        return modbus_error_word\n\n    def _set_pgva_status(self):\n        \"\"\"\n        Sets the internal messages for the incoming status word.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n        self._status = {\n            \"Status\": {0: \"Idle\", 1: \"Busy\"},\n            \"Pump\": {\n                0: \"Pump is off\",\n                1: \"Pump is building pressure\",\n                2: \"Pump is building vacuum\",\n            },\n            \"Pressure\": {\n                0: \"Pressure in the tank is nominal\",\n                1: \"Pressure in the tank is below threshold\",\n            },\n            \"Vacuum\": {\n                0: \"Vacuum in the tank is nominal\",\n                1: \"Vacuum in the tank is below threshold\",\n            },\n            \"EEPROM\": {0: \"No EEPROM write pending\", 1: \"EEPROM write pending\"},\n            \"TargetPressure\": {\n                0: \"Target pressure in progress\",\n                1: \"Target pressure achieved\",\n            },\n            \"Trigger\": {0: \"Trigger is closed\", 1: \"Trigger is open\"},\n            \"OutputValveControl\": {\n                0: \"Exhaust valve management disabled\",\n                1: \"Exhaust valve management enabled\",\n            },\n            \"OutputValve\": {0: \"Exhaust valve closed\", 1: \"Exhaust valve open\"},\n        }\n\n    def _set_pgva_warning(self):\n        \"\"\"\n        Sets the internal messages for the incoming warning word.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n        self._warning = {\n            \"SupplyVoltage\": {0: \"Reset\", 1: \"Abnormal supply voltage\"},\n            \"VacuumThreshold\": {\n                0: \"Reset\",\n                1: \"Vacuum generator cannot reach threshold\",\n            },\n            \"PressureThreshold\": {\n                0: \"Reset\",\n                1: \"Pressure generator cannot reach threshold\",\n            },\n            \"TargetPressure\": {\n                0: \"Reset\",\n                1: \"Preset output pressure cannot be reached\",\n            },\n            \"VacuumChamber\": {0: \"Reset\", 1: \"Vacuum chamber set below -500 mBar\"},\n            \"PressureChamber\": {0: \"Reset\", 1: \"Pressure chamber set above 500 mBar\"},\n            \"Pump\": {0: \"Reset\", 1: \"Pump ran for 9 minutes\"},\n            \"ExternalSensor\": {0: \"Reset\", 1: \"External Sensor Verification warning\"},\n        }\n\n    def _set_pgva_error(self):\n        \"\"\"\n        Sets the internal messages for the incoming error word.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n        self._pgva_error = {\n            \"PumpTimeout\": {0: \"Reset\", 1: \"Pump ran longer than 10 minutes\"},\n            \"TimeoutPressure\": {\n                0: \"Reset\",\n                1: \"Target output pressure not achieved in 8 minutes\",\n            },\n            \"ModbusError\": {\n                0: \"Reset\",\n                1: \"Modbus error occurred, please read modbus error word\",\n            },\n            \"LowVoltage\": {0: \"Reset\", 1: \"Power supply too low\"},\n            \"HighVoltage\": {0: \"Reset\", 1: \"Power supply too high\"},\n            \"TimeoutExternalSensor\": {0: \"Reset\", 1: \"External sensor check timed out\"},\n        }\n\n    def _set_modbus_error(self):\n        \"\"\"\n        Sets the internal messages for the incoming modbus error word.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n        modbus_message = \"The Modbus command was not executed\"\n        self._modbus_error = {\n            \"OutputActuationTime\": {\n                0: \"Reset\",\n                1: f\"Trigger time is outside of input range, {modbus_message}\",\n            },\n            \"PressureThreshold\": {\n                0: \"Reset\",\n                1: f\"Pressure threshold outside of input range, {modbus_message}\",\n            },\n            \"VacuumThreshold\": {\n                0: \"Reset\",\n                1: f\"Vacuum threshold outside of input range, {modbus_message}\",\n            },\n            \"OutputPressure\": {\n                0: \"Reset\",\n                1: f\"OutputPressure is outside of input range, {modbus_message}\",\n            },\n            \"ModbusID\": {\n                0: \"Reset\",\n                1: f\"Modbus Unit ID out of range, {modbus_message}\",\n            },\n            \"IPAddress\": {\n                0: \"Reset\",\n                1: f\"IP address does not comply with the restrictions, {modbus_message}\",\n            },\n            \"ManualTrigger\": {\n                0: \"Reset\",\n                1: f\"Manual trigger input is invalid, {modbus_message}\",\n            },\n            \"IncorrectNumberRegisters\": {\n                0: \"Reset\",\n                1: f\"Invalid number of registers can be written, {modbus_message}\",\n            },\n            \"Register\": {\n                0: \"Reset\",\n                1: f\"\"\"Register is write protected and cannot be written to,\n                         {modbus_message}\"\"\",\n            },\n            \"DHCP\": {\n                0: \"Reset\",\n                1: f\"\"\"Input values are outside of the permissable range,\n                     {modbus_message}\"\"\",\n            },\n            \"ExternalSensor\": {\n                0: \"Reset\",\n                1: f\"\"\"The input values are outside of the permissable range,\n                               {modbus_message}\"\"\",\n            },\n            \"ExhaustValveVolume\": {\n                0: \"Reset\",\n                1: f\"\"\"The input values are outside of the permissable range,\n                                   {modbus_message}\"\"\",\n            },\n        }\n\n    def _convert_twos_comp(self, val, bits):\n        \"\"\"\n        Converts a 2 compliment value into the actual signed integer value.\n\n        Args:\n            val: value\n            bits: number of bits\n\n        Returns:\n            Converted signed integer value\n        \"\"\"\n        if (val &amp; (1 &lt;&lt; (bits - 1))) != 0:  # if sign bit is set e.g., 8bit: 128-255\n            val = val - (1 &lt;&lt; bits)  # compute negative value\n        return val\n</code></pre>"},{"location":"autoapi/pgva/pgva_communication/#pgva.pgva_communication.PGVAModbusClient.__init__","title":"<code>__init__(config)</code>  <code>abstractmethod</code>","text":"<p>Base abstract class init, ModbusTCP and ModbusSerial will have their own implemenation.</p> Source code in <code>src/pgva/pgva_communication.py</code> <pre><code>@abstractmethod\ndef __init__(self, config):\n    \"\"\"Base abstract class init, ModbusTCP and ModbusSerial will have their own implemenation.\"\"\"\n    self._config = config\n</code></pre>"},{"location":"autoapi/pgva/pgva_communication/#pgva.pgva_communication.PGVAModbusClient.get_error_word","title":"<code>get_error_word()</code>","text":"<p>Reads the error word and outputs it to the log.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Current error word of the PGVA-1</p> Source code in <code>src/pgva/pgva_communication.py</code> <pre><code>def get_error_word(self) -&gt; dict:\n    \"\"\"\n    Reads the error word and outputs it to the log.\n\n    Args:\n        None\n\n    Returns:\n        Current error word of the PGVA-1\n    \"\"\"\n    pgva_error = self._get_data(commands.ERROR_WORD)\n    error_word = {\n        \"PumpTimeout\": self._pgva_error[\"PumpTimeout\"][pgva_error &amp; 1],\n        \"TimeoutPressure\": self._pgva_error[\"TimeoutPressure\"][(pgva_error &gt;&gt; 1) &amp; 1],\n        \"ModbusError\": self._pgva_error[\"ModbusError\"][(pgva_error &gt;&gt; 2) &amp; 1],\n        \"LowVoltage\": self._pgva_error[\"LowVoltage\"][(pgva_error &gt;&gt; 3) &amp; 1],\n        \"HighVoltage\": self._pgva_error[\"HighVoltage\"][(pgva_error &gt;&gt; 4) &amp; 1],\n        \"TimeoutExternalSensor\": self._pgva_error[\"TimeoutExternalSensor\"][(pgva_error &gt;&gt; 5) &amp; 1],\n    }\n    if any(v != \"Reset\" for v in error_word.values()):\n        logger.error(\"Active PGVA error(s): %s\", error_word)\n    else:\n        logger.debug(\"Error word: %s\", error_word)\n    return error_word\n</code></pre>"},{"location":"autoapi/pgva/pgva_communication/#pgva.pgva_communication.PGVAModbusClient.get_firmware_version","title":"<code>get_firmware_version()</code>","text":"<p>Gets the current firmware version located on the PGVA.</p> <p>Returns:</p> Type Description <code>list</code> <p>List of the version</p> Source code in <code>src/pgva/pgva_communication.py</code> <pre><code>def get_firmware_version(self) -&gt; list:\n    \"\"\"Gets the current firmware version located on the PGVA.\n\n    Args:\n        None\n\n    Returns:\n        List of the version\n    \"\"\"\n    self.version = []\n    if len(self.version) &lt; 3:\n        self.version.append(self._get_data(commands.FIRMWARE_VERSION))\n        self.version.append(self._get_data(commands.FIRMWARE_SUBVERSION))\n        self.version.append(self._get_data(commands.FIRMWARE_BUILD))\n        logger.debug(\"Firmware version retrieved: %s\", self.version)\n        return self.version\n    return [0, 0, 0]\n</code></pre>"},{"location":"autoapi/pgva/pgva_communication/#pgva.pgva_communication.PGVAModbusClient.get_internal_sensor_data","title":"<code>get_internal_sensor_data()</code>","text":"<p>Reads the internal Vacuum and Pressure chambers as well as the output pressure sensor.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary of the sensor values</p> Source code in <code>src/pgva/pgva_communication.py</code> <pre><code>def get_internal_sensor_data(self) -&gt; dict:\n    \"\"\"\n    Reads the internal Vacuum and Pressure chambers as well as the output pressure sensor.\n\n    Args:\n        None\n\n    Returns:\n        Dictionary of the sensor values\n    \"\"\"\n    status = {}\n    if self.version[0:3] != [2, 1, 3]:\n        status[\"Extsensor\"] = self._get_data(commands.EXTERNAL_SENSOR_VALUE)\n    status[\"VacuumChamber\"] = self.get_vacuum_chamber()\n    status[\"PressureChamber\"] = self.get_pressure_chamber()\n    status[\"OutputPressure\"] = self.get_output_pressure()\n    logger.debug(\"Internal sensor data: %s\", status)\n    return status\n</code></pre>"},{"location":"autoapi/pgva/pgva_communication/#pgva.pgva_communication.PGVAModbusClient.get_modbus_error_word","title":"<code>get_modbus_error_word()</code>","text":"<p>Reads the modbus error word and outputs it to the log.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Current modbus error word of the PGVA-1</p> Source code in <code>src/pgva/pgva_communication.py</code> <pre><code>def get_modbus_error_word(self) -&gt; dict:\n    \"\"\"\n    Reads the modbus error word and outputs it to the log.\n\n    Args:\n        None\n\n    Returns:\n        Current modbus error word of the PGVA-1\n    \"\"\"\n    modbus_error = self._get_data(commands.LAST_MODBUS_ERROR)\n    modbus_error_word = {\"OutputActuationTime\": self._modbus_error[\"OutputActuationTime\"][modbus_error &amp; 1]}\n    if any(v != \"Reset\" for v in modbus_error_word.values()):\n        logger.error(\"Active Modbus error(s): %s\", modbus_error_word)\n    else:\n        logger.debug(\"Modbus error word: %s\", modbus_error_word)\n    return modbus_error_word\n</code></pre>"},{"location":"autoapi/pgva/pgva_communication/#pgva.pgva_communication.PGVAModbusClient.get_output_pressure","title":"<code>get_output_pressure()</code>","text":"<p>Reads the output port pressure.</p> <p>Returns:</p> Type Description <code>int</code> <p>Output pressure in mBar</p> Source code in <code>src/pgva/pgva_communication.py</code> <pre><code>def get_output_pressure(self) -&gt; int:\n    \"\"\"\n    Reads the output port pressure.\n\n    Args:\n        None\n\n    Returns:\n        Output pressure in mBar\n    \"\"\"\n    pressure = self._get_data(commands.OUTPUT_PRESSURE_ACTUAL_MBAR)\n    if pressure &gt; 500:\n        result = self._convert_twos_comp(pressure, len(bin(pressure)[2:]))\n        logger.debug(\"Output pressure reading: %s mBar\", result)\n        return result\n    logger.debug(\"Output pressure reading: %s mBar\", pressure)\n    return pressure\n</code></pre>"},{"location":"autoapi/pgva/pgva_communication/#pgva.pgva_communication.PGVAModbusClient.get_pressure_chamber","title":"<code>get_pressure_chamber()</code>","text":"<p>Reads the internal pressure chamber pressure.</p> <p>Returns:</p> Type Description <code>int</code> <p>Pressure chamber pressure in mBar</p> Source code in <code>src/pgva/pgva_communication.py</code> <pre><code>def get_pressure_chamber(self) -&gt; int:\n    \"\"\"\n    Reads the internal pressure chamber pressure.\n\n    Args:\n        None\n\n    Returns:\n        Pressure chamber pressure in mBar\n    \"\"\"\n    result = self._get_data(commands.PRESSURE_ACTUAL_MBAR)\n    logger.debug(\"Pressure chamber reading: %s mBar\", result)\n    return result\n</code></pre>"},{"location":"autoapi/pgva/pgva_communication/#pgva.pgva_communication.PGVAModbusClient.get_status_word","title":"<code>get_status_word()</code>","text":"<p>Reads the status word and outputs it to the log.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Current status of the PGVA-1</p> Source code in <code>src/pgva/pgva_communication.py</code> <pre><code>def get_status_word(self) -&gt; dict:\n    \"\"\"\n    Reads the status word and outputs it to the log.\n\n    Args:\n        None\n\n    Returns:\n        Current status of the PGVA-1\n    \"\"\"\n    pgva_status = self._get_data(commands.STATUS_WORD)\n    status_word = {\n        \"Status\": self._status[\"Status\"][pgva_status &amp; 1],\n        \"Pump\": self._status[\"Pump\"][(pgva_status &gt;&gt; 1) &amp; 0b11],\n        \"Pressure\": self._status[\"Pressure\"][(pgva_status &gt;&gt; 3) &amp; 1],\n        \"Vacuum\": self._status[\"Vacuum\"][(pgva_status &gt;&gt; 4) &amp; 1],\n        \"EEPROM\": self._status[\"EEPROM\"][(pgva_status &gt;&gt; 5) &amp; 1],\n        \"TargetPressure\": self._status[\"TargetPressure\"][(pgva_status &gt;&gt; 6) &amp; 1],\n        \"Trigger\": self._status[\"Trigger\"][(pgva_status &gt;&gt; 7) &amp; 1],\n        \"OutputValveControl\": self._status[\"OutputValveControl\"][(pgva_status &gt;&gt; 10) &amp; 1],\n        \"OutputValve\": self._status[\"OutputValve\"][(pgva_status &gt;&gt; 11) &amp; 1],\n    }\n\n    logger.debug(\"Status word: %s\", status_word)\n    return status_word\n</code></pre>"},{"location":"autoapi/pgva/pgva_communication/#pgva.pgva_communication.PGVAModbusClient.get_vacuum_chamber","title":"<code>get_vacuum_chamber()</code>","text":"<p>Reads the internal vacuum chamber pressure.</p> <p>Returns:</p> Type Description <code>int</code> <p>Vacuum chamber pressure in mBar</p> Source code in <code>src/pgva/pgva_communication.py</code> <pre><code>def get_vacuum_chamber(self) -&gt; int:\n    \"\"\"\n    Reads the internal vacuum chamber pressure.\n\n    Args:\n        None\n\n    Returns:\n        Vacuum chamber pressure in mBar\n    \"\"\"\n    vacuum = self._get_data(commands.VACUUM_ACTUAL_MBAR)\n    result = self._convert_twos_comp(vacuum, len(bin(vacuum)[2:]))\n    logger.debug(\"Vacuum chamber reading: %s mBar\", result)\n    return result\n</code></pre>"},{"location":"autoapi/pgva/pgva_communication/#pgva.pgva_communication.PGVAModbusClient.get_warning_word","title":"<code>get_warning_word()</code>","text":"<p>Reads the warning word and outputs it to the log.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Current warning word of the PGVA-1</p> Source code in <code>src/pgva/pgva_communication.py</code> <pre><code>def get_warning_word(self) -&gt; dict:\n    \"\"\"\n    Reads the warning word and outputs it to the log.\n\n    Args:\n        None\n\n    Returns:\n       Current warning word of the PGVA-1\n    \"\"\"\n    pgva_warning = self._get_data(commands.WARNING_WORD)\n    warning_word = {\n        \"SupplyVoltage\": self._warning[\"SupplyVoltage\"][pgva_warning &amp; 1],\n        \"VacuumThreshold\": self._warning[\"VacuumThreshold\"][(pgva_warning &gt;&gt; 1) &amp; 1],\n        \"PressureThreshold\": self._warning[\"PressureThreshold\"][(pgva_warning &gt;&gt; 2) &amp; 1],\n        \"TargetPressure\": self._warning[\"TargetPressure\"][(pgva_warning &gt;&gt; 4) &amp; 1],\n        \"VacuumChamber\": self._warning[\"VacuumChamber\"][(pgva_warning &gt;&gt; 5) &amp; 1],\n        \"Pump\": self._warning[\"Pump\"][(pgva_warning &gt;&gt; 7) &amp; 1],\n        \"ExternalSensor\": self._warning[\"ExternalSensor\"][(pgva_warning &gt;&gt; 9) &amp; 1],\n    }\n    if any(v != \"Reset\" for v in warning_word.values()):\n        logger.warning(\"Active PGVA warning(s): %s\", warning_word)\n    else:\n        logger.debug(\"Warning word: %s\", warning_word)\n    return warning_word\n</code></pre>"},{"location":"autoapi/pgva/pgva_communication/#pgva.pgva_communication.PGVAModbusClient.print_driver_information","title":"<code>print_driver_information()</code>","text":"<p>Logs all driver parameters at INFO level.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/pgva/pgva_communication.py</code> <pre><code>def print_driver_information(self) -&gt; None:\n    \"\"\"\n    Logs all driver parameters at INFO level.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    internal_data = self.get_internal_sensor_data()\n    logger.info(\"Driver Information:\")\n    logger.info(\"  Firmware version: %s\", self.version)\n    logger.info(\"  Connection type: %s\", self._config.interface)\n    logger.info(\"  Sensor data: %s\", internal_data)\n</code></pre>"},{"location":"autoapi/pgva/pgva_communication/#pgva.pgva_communication.PGVAModbusClient.set_actuation_time","title":"<code>set_actuation_time(actuation_time)</code>","text":"<p>Sets the valve actuation time which is then immediately executed.</p> <p>Parameters:</p> Name Type Description Default <code>actuation_time</code> <code>int</code> <p>Time in ms for valve to be open</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If actuation_time is outside the valid range of 5 to 65535 ms.</p> Source code in <code>src/pgva/pgva_communication.py</code> <pre><code>def set_actuation_time(self, actuation_time: int) -&gt; None:\n    \"\"\"\n    Sets the valve actuation time which is then immediately executed.\n\n    Args:\n        actuation_time (int): Time in ms for valve to be open\n\n    Returns:\n        None\n\n    Raises:\n        ValueError: If actuation_time is outside the valid range of 5 to 65535 ms.\n    \"\"\"\n    if actuation_time in range(5, 65535):\n        logger.info(\"Triggering actuation valve for %s ms\", actuation_time)\n        self._set_data(commands.VALVE_ACTUATION_TIME, actuation_time)\n        # time.sleep(actuation_time / 1000)\n    else:\n        logger.error(\n            \"Error: acuation time out of range (5, 65535), inputted: %s\",\n            str(actuation_time),\n        )\n        raise ValueError(\"Error: Value entered for actuation time needs to be between 5 and 65535\")\n</code></pre>"},{"location":"autoapi/pgva/pgva_communication/#pgva.pgva_communication.PGVAModbusClient.set_output_pressure","title":"<code>set_output_pressure(pressure)</code>","text":"<p>Sets the output pressure for the PGVA.</p> <p>Parameters:</p> Name Type Description Default <code>pressure</code> <code>int</code> <p>Any range between -450 ... 450</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If pressure is outside the supported output pressure range.</p> Source code in <code>src/pgva/pgva_communication.py</code> <pre><code>def set_output_pressure(self, pressure: int) -&gt; None:\n    \"\"\"\n    Sets the output pressure for the PGVA.\n\n    Args:\n        pressure (int): Any range between -450 ... 450\n\n    Returns:\n        None\n\n    Raises:\n        ValueError: If pressure is outside the supported output pressure range.\n    \"\"\"\n    if self._validate_pump_enable():\n        if consts.MINIMUM_OUTPUT_PRESSURE_MBAR &lt;= pressure &lt;= consts.MAXIMUM_OUTPUT_PRESSURE_MBAR:\n            logger.info(\"Setting output pressure to %s mBar\", pressure)\n            self._set_data(commands.OUTPUT_PRESSURE_MBAR, pressure)\n        else:\n            logger.error(\"Input pressure outside of working range: %s\", str(pressure))\n            raise ValueError(\"Input pressure outside of working range\")\n</code></pre>"},{"location":"autoapi/pgva/pgva_communication/#pgva.pgva_communication.PGVAModbusClient.set_pressure_chamber","title":"<code>set_pressure_chamber(pressure)</code>","text":"<p>Sets the internal pressure chamber.</p> <p>Parameters:</p> Name Type Description Default <code>pressure</code> <code>int</code> <p>Range between 200 ... 1000 mBar</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If pressure is outside the supported pressure chamber range.</p> Source code in <code>src/pgva/pgva_communication.py</code> <pre><code>def set_pressure_chamber(self, pressure: int) -&gt; None:\n    \"\"\"\n    Sets the internal pressure chamber.\n\n    Args:\n        pressure (int): Range between 200 ... 1000 mBar\n\n    Returns:\n        None\n\n    Raises:\n        ValueError: If pressure is outside the supported pressure chamber range.\n    \"\"\"\n    if consts.MINIMUM_PRESSURE_CHAMBER_MBAR &lt;= pressure &lt;= consts.MAXIMUM_PRESSURE_CHAMBER_MBAR:\n        # Using the pressure scaling factor provided via operation manual of the PGVA\n        logger.info(\"Setting pressure chamber to %s mBar\", pressure)\n        pressure = int(pressure * consts.PRESSURE_CHAMBER_CONVERSION_FACTOR)\n        self._set_data(commands.PRESSURE_THRESHOLD, pressure)\n    else:\n        err = f\"Error: {pressure} input pressure outside of PGVA-1 working conditions. Please enter a value between 200 and 1000 mBar.\"\n        logger.error(err)\n        raise ValueError(err)\n</code></pre>"},{"location":"autoapi/pgva/pgva_communication/#pgva.pgva_communication.PGVAModbusClient.set_vacuum_chamber","title":"<code>set_vacuum_chamber(vacuum)</code>","text":"<p>Sets the internal vacuum chamber.</p> <p>Parameters:</p> Name Type Description Default <code>vacuum</code> <code>int</code> <p>Range between -200 ... -620 mBar</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If vacuum is outside the supported vacuum chamber range.</p> Source code in <code>src/pgva/pgva_communication.py</code> <pre><code>def set_vacuum_chamber(self, vacuum: int) -&gt; None:\n    \"\"\"\n    Sets the internal vacuum chamber.\n\n    Args:\n        vacuum (int): Range between -200 ... -620 mBar\n\n    Returns:\n        None\n\n    Raises:\n        ValueError: If vacuum is outside the supported vacuum chamber range.\n    \"\"\"\n    if consts.MINIMUM_VACUUM_CHAMBER_MBAR &lt;= vacuum &lt;= consts.MAXIMUM_VACUUM_CHAMBER_MBAR:\n        logger.info(\"Setting vacuum chamber to %s mBar\", vacuum)\n        vacuum = int(vacuum * consts.VACUUM_CHAMBER_CONVERSION_FACTOR)\n        self._set_data(commands.VACUUM_THRESHOLD, vacuum)\n    else:\n        err = f\"Error: {vacuum} input pressure outside of PGVA-1 working conditions.\"\n        logger.error(err)\n        raise ValueError(err)\n</code></pre>"},{"location":"autoapi/pgva/pgva_communication/#pgva.pgva_communication.PGVAModbusClient.toggle_manual_trigger","title":"<code>toggle_manual_trigger(toggle)</code>","text":"<p>Toggles the manual trigger to either on or off.</p> <p>Parameters:</p> Name Type Description Default <code>toggle</code> <code>int</code> <p>Bool value, 1 for on, 0 for off</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Manual trigger is not implemented due to a firmware limitation.</p> Source code in <code>src/pgva/pgva_communication.py</code> <pre><code>def toggle_manual_trigger(self, toggle: bool) -&gt; None:\n    \"\"\"\n    Toggles the manual trigger to either on or off.\n\n    Args:\n        toggle (int): Bool value, 1 for on, 0 for off\n\n    Returns:\n        None\n\n    Raises:\n        NotImplementedError: Manual trigger is not implemented due to a firmware limitation.\n    \"\"\"\n    # self._set_data(commands.MANUAL_TRIGGER, int(toggle))\n    logger.warning(\"toggle_manual_trigger() is not implemented: known firmware bug in PGVA-1 firmware &lt;= 2.0.45\")\n    raise NotImplementedError(\"\"\"\n                              Manual trigger not implemented. There is a bug that exists in the PGVA-1 firmware &lt;=2.0.45\n                              that prevents this function from working as intended\n                              \"\"\")\n</code></pre>"},{"location":"autoapi/pgva/pgva_communication/#pgva.pgva_communication.PGVAModbusClient.toggle_pump","title":"<code>toggle_pump(toggle)</code>","text":"<p>Enables or disables the pump for creating pressure / vacuum.</p> <p>Parameters:</p> Name Type Description Default <code>toggle</code> <code>bool</code> <p>1 for on, 0 for off</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/pgva/pgva_communication.py</code> <pre><code>def toggle_pump(self, toggle: bool) -&gt; None:\n    \"\"\"\n    Enables or disables the pump for creating pressure / vacuum.\n\n    Args:\n        toggle (bool): 1 for on, 0 for off\n\n    Returns:\n        None\n    \"\"\"\n    logger.info(\"Toggling pump: %s\", \"ON\" if toggle else \"OFF\")\n    if self.version[0:3] != [2, 1, 3]:\n        self._set_data(commands.PUMP_ENABLE, toggle)\n    else:\n        logger.info(\"PGVA firmware does not support the enable/disable pump function\")\n</code></pre>"},{"location":"autoapi/pgva/pgva_communication/#pgva.pgva_communication.PGVAModbusSerial","title":"<code>PGVAModbusSerial</code>","text":"<p>               Bases: <code>PGVAModbusClient</code></p> <p>This class is the interface backend for using Modbus Serial communication.</p> Source code in <code>src/pgva/pgva_communication.py</code> <pre><code>class PGVAModbusSerial(PGVAModbusClient):\n    \"\"\"This class is the interface backend for using Modbus Serial communication.\"\"\"\n\n    def __init__(self, config: PGVAConfig) -&gt; None:\n        \"\"\"\n        Serial Client Interface Constructor.\n\n        Args:\n            config (PGVASerialConfig): A configuration class designated for ModbusSerial\n\n        Returns:\n            None\n\n        Raises:\n            TypeError: If config is not an instance of PGVASerialConfig.\n        \"\"\"\n        logger.warning(\"\"\"The Modbus Serial connection mode is currently experimental and under active development.\n                                It can currently only be instantiated directly.\n                                Use at your own risk.\"\"\")\n        super().__init__(config)\n        if not isinstance(config, PGVASerialConfig):\n            raise TypeError(\n                f\"\"\"Error: Config does not match the ModbusSerial backend.\n                            The type passed in was: {type(config)}\"\"\"\n            )\n        try:\n            self._config = config\n            self.client = ModbusSerialClient(port=self._config.com_port, baudrate=self._config.baudrate)\n            self.version = self.get_firmware_version()\n            self._set_modbus_error()\n            self._set_pgva_error()\n            self._set_pgva_status()\n            self._set_pgva_warning()\n            logger.info(\n                \"PGVA connected via Serial \u2014 port: %s, baudrate: %s, unit_id: %s, firmware: %s\",\n                self._config.com_port,\n                self._config.baudrate,\n                self._config.unit_id,\n                self.version,\n            )\n        except RuntimeError as run_err:\n            logger.error(\"Error with serial connection: %s\", str(run_err))\n            logger.info(self._config)\n\n    def print_driver_information(self) -&gt; None:\n        \"\"\"\n        Display all available information about the PGVA driver.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n        super().print_driver_information()\n        logger.info(\"  Serial Port: %s\", self._config.com_port)\n        logger.info(\"  Baudrate: %s\", self._config.baudrate)\n        logger.info(\"  Modbus Slave ID: %s\", self._config.unit_id)\n</code></pre>"},{"location":"autoapi/pgva/pgva_communication/#pgva.pgva_communication.PGVAModbusSerial.__init__","title":"<code>__init__(config)</code>","text":"<p>Serial Client Interface Constructor.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>PGVASerialConfig</code> <p>A configuration class designated for ModbusSerial</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If config is not an instance of PGVASerialConfig.</p> Source code in <code>src/pgva/pgva_communication.py</code> <pre><code>def __init__(self, config: PGVAConfig) -&gt; None:\n    \"\"\"\n    Serial Client Interface Constructor.\n\n    Args:\n        config (PGVASerialConfig): A configuration class designated for ModbusSerial\n\n    Returns:\n        None\n\n    Raises:\n        TypeError: If config is not an instance of PGVASerialConfig.\n    \"\"\"\n    logger.warning(\"\"\"The Modbus Serial connection mode is currently experimental and under active development.\n                            It can currently only be instantiated directly.\n                            Use at your own risk.\"\"\")\n    super().__init__(config)\n    if not isinstance(config, PGVASerialConfig):\n        raise TypeError(\n            f\"\"\"Error: Config does not match the ModbusSerial backend.\n                        The type passed in was: {type(config)}\"\"\"\n        )\n    try:\n        self._config = config\n        self.client = ModbusSerialClient(port=self._config.com_port, baudrate=self._config.baudrate)\n        self.version = self.get_firmware_version()\n        self._set_modbus_error()\n        self._set_pgva_error()\n        self._set_pgva_status()\n        self._set_pgva_warning()\n        logger.info(\n            \"PGVA connected via Serial \u2014 port: %s, baudrate: %s, unit_id: %s, firmware: %s\",\n            self._config.com_port,\n            self._config.baudrate,\n            self._config.unit_id,\n            self.version,\n        )\n    except RuntimeError as run_err:\n        logger.error(\"Error with serial connection: %s\", str(run_err))\n        logger.info(self._config)\n</code></pre>"},{"location":"autoapi/pgva/pgva_communication/#pgva.pgva_communication.PGVAModbusSerial.print_driver_information","title":"<code>print_driver_information()</code>","text":"<p>Display all available information about the PGVA driver.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/pgva/pgva_communication.py</code> <pre><code>def print_driver_information(self) -&gt; None:\n    \"\"\"\n    Display all available information about the PGVA driver.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    super().print_driver_information()\n    logger.info(\"  Serial Port: %s\", self._config.com_port)\n    logger.info(\"  Baudrate: %s\", self._config.baudrate)\n    logger.info(\"  Modbus Slave ID: %s\", self._config.unit_id)\n</code></pre>"},{"location":"autoapi/pgva/pgva_communication/#pgva.pgva_communication.PGVAModbusTCP","title":"<code>PGVAModbusTCP</code>","text":"<p>               Bases: <code>PGVAModbusClient</code></p> <p>This class is the interface backend for using Modbus TCP communication.</p> <p>TODO: Add typical usage example</p> Source code in <code>src/pgva/pgva_communication.py</code> <pre><code>class PGVAModbusTCP(PGVAModbusClient):\n    \"\"\"\n    This class is the interface backend for using Modbus TCP communication.\n\n    TODO: Add typical usage example\n    \"\"\"\n\n    def __init__(self, config: PGVAConfig) -&gt; None:\n        \"\"\"\n        TCP Client Interface Constructor.\n\n        Args:\n            config (PGVATCPConfig): A configuration class designated for ModbusTCP\n\n        Returns:\n            None\n\n        Raises:\n            TypeError: If config is not an instance of PGVATCPConfig.\n        \"\"\"\n        super().__init__(config)\n        if not isinstance(config, PGVATCPConfig):\n            raise TypeError(\n                f\"\"\"Error: Config does not match the ModbusTCP backend.\n                The type passed in was: {type(config)}\"\"\"\n            )\n        try:\n            self._config = config\n            self.client = ModbusTcpClient(host=self._config.ip, port=self._config.port)\n            self._set_modbus_error()\n            self._set_pgva_error()\n            self._set_pgva_status()\n            self._set_pgva_warning()\n            self.version = self.get_firmware_version()\n            logger.info(\n                \"PGVA connected via TCP \u2014 host: %s, port: %s, unit_id: %s, firmware: %s\",\n                self._config.ip,\n                self._config.port,\n                self._config.unit_id,\n                self.version,\n            )\n        except socket.error as socket_error:\n            logger.error(\"Socket error: %s. \", str(socket_error))\n            logger.info(self._config)\n\n    def print_driver_information(self) -&gt; None:\n        \"\"\"\n        Display all available information about the PGVA driver.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n        super().print_driver_information()\n        logger.info(\"  IP Address: %s\", self._config.ip)\n        logger.info(\"  Port: %s\", self._config.port)\n        logger.info(\"  Modbus Slave ID: %s\", self._config.unit_id)\n</code></pre>"},{"location":"autoapi/pgva/pgva_communication/#pgva.pgva_communication.PGVAModbusTCP.__init__","title":"<code>__init__(config)</code>","text":"<p>TCP Client Interface Constructor.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>PGVATCPConfig</code> <p>A configuration class designated for ModbusTCP</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If config is not an instance of PGVATCPConfig.</p> Source code in <code>src/pgva/pgva_communication.py</code> <pre><code>def __init__(self, config: PGVAConfig) -&gt; None:\n    \"\"\"\n    TCP Client Interface Constructor.\n\n    Args:\n        config (PGVATCPConfig): A configuration class designated for ModbusTCP\n\n    Returns:\n        None\n\n    Raises:\n        TypeError: If config is not an instance of PGVATCPConfig.\n    \"\"\"\n    super().__init__(config)\n    if not isinstance(config, PGVATCPConfig):\n        raise TypeError(\n            f\"\"\"Error: Config does not match the ModbusTCP backend.\n            The type passed in was: {type(config)}\"\"\"\n        )\n    try:\n        self._config = config\n        self.client = ModbusTcpClient(host=self._config.ip, port=self._config.port)\n        self._set_modbus_error()\n        self._set_pgva_error()\n        self._set_pgva_status()\n        self._set_pgva_warning()\n        self.version = self.get_firmware_version()\n        logger.info(\n            \"PGVA connected via TCP \u2014 host: %s, port: %s, unit_id: %s, firmware: %s\",\n            self._config.ip,\n            self._config.port,\n            self._config.unit_id,\n            self.version,\n        )\n    except socket.error as socket_error:\n        logger.error(\"Socket error: %s. \", str(socket_error))\n        logger.info(self._config)\n</code></pre>"},{"location":"autoapi/pgva/pgva_communication/#pgva.pgva_communication.PGVAModbusTCP.print_driver_information","title":"<code>print_driver_information()</code>","text":"<p>Display all available information about the PGVA driver.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/pgva/pgva_communication.py</code> <pre><code>def print_driver_information(self) -&gt; None:\n    \"\"\"\n    Display all available information about the PGVA driver.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    super().print_driver_information()\n    logger.info(\"  IP Address: %s\", self._config.ip)\n    logger.info(\"  Port: %s\", self._config.port)\n    logger.info(\"  Modbus Slave ID: %s\", self._config.unit_id)\n</code></pre>"},{"location":"autoapi/pgva/pgva_config/","title":"pgva_config","text":"<p>Wrapper for the configurations of the PGVA communication backend.</p> <p>This holds all the different PGVA-1 configurations for different backends</p>"},{"location":"autoapi/pgva/pgva_config/#pgva.pgva_config.PGVAConfig","title":"<code>PGVAConfig</code>  <code>dataclass</code>","text":"<p>Generic class PGVA-1 dataclass for initalization.</p> <p>Attributes:</p> Name Type Description <code>interface</code> <code>str</code> <p>Interface type. Ex: 'tcp/ip', 'serial', 'codes</p> <code>unit_id</code> <code>int</code> <p>Modbus unit ID of the PGVA-1 device</p> Source code in <code>src/pgva/pgva_config.py</code> <pre><code>@dataclass(kw_only=True)\nclass PGVAConfig:\n    \"\"\"\n    Generic class PGVA-1 dataclass for initalization.\n\n    Attributes:\n        interface (str): Interface type. Ex: 'tcp/ip', 'serial', 'codes\n        unit_id (int): Modbus unit ID of the PGVA-1 device\n    \"\"\"\n\n    interface: str\n    unit_id: int = 1\n</code></pre>"},{"location":"autoapi/pgva/pgva_config/#pgva.pgva_config.PGVASerialConfig","title":"<code>PGVASerialConfig</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PGVAConfig</code></p> <p>Class PGVA-1 configuration for serial connection.</p> <p>Attributes:</p> Name Type Description <code>com_port</code> <code>str</code> <p>COM port of the serial connection. Ex: 'COM3' or '/dev/ttyUSB0'</p> <code>baudrate</code> <code>int</code> <p>Baudrate of the serial connection. Ex: 9600, 19200, 115200</p> Source code in <code>src/pgva/pgva_config.py</code> <pre><code>@dataclass(kw_only=True)\nclass PGVASerialConfig(PGVAConfig):\n    \"\"\"\n    Class PGVA-1 configuration for serial connection.\n\n    Attributes:\n        com_port (str): COM port of the serial connection. Ex: 'COM3' or '/dev/ttyUSB0'\n        baudrate (int): Baudrate of the serial connection. Ex: 9600, 19200, 115200\n    \"\"\"\n\n    com_port: str\n    baudrate: int\n</code></pre>"},{"location":"autoapi/pgva/pgva_config/#pgva.pgva_config.PGVATCPConfig","title":"<code>PGVATCPConfig</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PGVAConfig</code></p> <p>Class for PGVA-1 configuration class for ModbusTCP connection.</p> <p>Attributes:</p> Name Type Description <code>ip</code> <code>str</code> <p>IP address of PGVA in string form. Ex: '192.168.0.1'</p> <code>port</code> <code>int</code> <p>Default to 502, port of connunication for the PGVA-1</p> Source code in <code>src/pgva/pgva_config.py</code> <pre><code>@dataclass(kw_only=True)\nclass PGVATCPConfig(PGVAConfig):\n    \"\"\"\n    Class for PGVA-1 configuration class for ModbusTCP connection.\n\n    Attributes:\n        ip (str): IP address of PGVA in string form. Ex: '192.168.0.1'\n        port (int): Default to 502, port of connunication for the PGVA-1\n    \"\"\"\n\n    ip: str\n    port: int = 502\n</code></pre>"},{"location":"autoapi/pgva/pgva_interface/","title":"pgva_interface","text":"<p>PGVA Interface class.</p> <p>Abstract interface description for exportation to CoDeSys libraries and other systems for consistent integration</p>"},{"location":"autoapi/pgva/pgva_interface/#pgva.pgva_interface.PGVAInterface","title":"<code>PGVAInterface</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Interface class for PGVA that needs to be implemented by the user.</p> Source code in <code>src/pgva/pgva_interface.py</code> <pre><code>class PGVAInterface(ABC):\n    \"\"\"Interface class for PGVA that needs to be implemented by the user.\"\"\"\n\n    @abstractmethod\n    def __init__(self, config):\n        \"\"\"Abstract function for constructor of the driver class.\"\"\"\n        pass\n\n    @abstractmethod\n    def set_output_pressure(self, pressure: int):\n        \"\"\"Abstract function for setting output pressure.\"\"\"\n        pass\n\n    @abstractmethod\n    def trigger_actuation_valve(self, actuation_time: int):\n        \"\"\"Abstract function for running the actuation valve.\"\"\"\n        pass\n\n    @abstractmethod\n    def set_pressure_chamber(self, pressure: int):\n        \"\"\"Abstract function for setting internal pressure chamber.\"\"\"\n        pass\n\n    @abstractmethod\n    def set_vacuum_chamber(self, vacuum: int):\n        \"\"\"\n        Sets the internal vacuum chamber.\n\n        Args:\n            vacuum: mBar\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_pressure_chamber(self):\n        \"\"\"\n        Returns the current reading of the pressure chamber in mBar.\n\n        Returns:\n            Chamber pressure\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_vacuum_chamber(self):\n        \"\"\"\n        Returns the current reading of the vacuum chamber in mBar.\n\n        Returns:\n            Vacuum pressure\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_output_pressure(self):\n        \"\"\"\n        Returns the output port pressure in mBar.\n\n        Returns:\n            Output Pressure\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_internal_sensor_data(self):\n        \"\"\"\n        Returns all the internal sensor data in mBar.\n\n        Returns:\n            Dictionary: All current readings of internal sensors\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def toggle_pump(self, toggle: bool):\n        \"\"\"\n        Enable / Disables the pump.\n\n        Args:\n            toggle: 1 for on, 0 for off\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_status_word(self):\n        \"\"\"\n        Gets the status word from the PGVA.\n\n        Returns:\n            Status word: Dictionary of status\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_warning_word(self):\n        \"\"\"\n        Gets the warning word from the PGVA-1.\n\n        Returns:\n            Warning word: Dictionary of warning word\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_error_word(self):\n        \"\"\"\n        Gets the error word from the PGVA-1.\n\n        Returns:\n            Error word: Dictionary of error word\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_modbus_error_word(self):\n        \"\"\"\n        Get the error word from the PGVA-1.\n\n        Returns:\n            Modbus error word: Dictionary of modbus error word\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def toggle_trigger(self, trigger: bool):\n        \"\"\"\n        Toggles the trigger.\n\n        Args:\n            trigger: boolean value for on or off\n        \"\"\"\n        pass\n</code></pre>"},{"location":"autoapi/pgva/pgva_interface/#pgva.pgva_interface.PGVAInterface.__init__","title":"<code>__init__(config)</code>  <code>abstractmethod</code>","text":"<p>Abstract function for constructor of the driver class.</p> Source code in <code>src/pgva/pgva_interface.py</code> <pre><code>@abstractmethod\ndef __init__(self, config):\n    \"\"\"Abstract function for constructor of the driver class.\"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/pgva/pgva_interface/#pgva.pgva_interface.PGVAInterface.get_error_word","title":"<code>get_error_word()</code>  <code>abstractmethod</code>","text":"<p>Gets the error word from the PGVA-1.</p> <p>Returns:</p> Type Description <p>Error word: Dictionary of error word</p> Source code in <code>src/pgva/pgva_interface.py</code> <pre><code>@abstractmethod\ndef get_error_word(self):\n    \"\"\"\n    Gets the error word from the PGVA-1.\n\n    Returns:\n        Error word: Dictionary of error word\n    \"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/pgva/pgva_interface/#pgva.pgva_interface.PGVAInterface.get_internal_sensor_data","title":"<code>get_internal_sensor_data()</code>  <code>abstractmethod</code>","text":"<p>Returns all the internal sensor data in mBar.</p> <p>Returns:</p> Name Type Description <code>Dictionary</code> <p>All current readings of internal sensors</p> Source code in <code>src/pgva/pgva_interface.py</code> <pre><code>@abstractmethod\ndef get_internal_sensor_data(self):\n    \"\"\"\n    Returns all the internal sensor data in mBar.\n\n    Returns:\n        Dictionary: All current readings of internal sensors\n    \"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/pgva/pgva_interface/#pgva.pgva_interface.PGVAInterface.get_modbus_error_word","title":"<code>get_modbus_error_word()</code>  <code>abstractmethod</code>","text":"<p>Get the error word from the PGVA-1.</p> <p>Returns:</p> Type Description <p>Modbus error word: Dictionary of modbus error word</p> Source code in <code>src/pgva/pgva_interface.py</code> <pre><code>@abstractmethod\ndef get_modbus_error_word(self):\n    \"\"\"\n    Get the error word from the PGVA-1.\n\n    Returns:\n        Modbus error word: Dictionary of modbus error word\n    \"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/pgva/pgva_interface/#pgva.pgva_interface.PGVAInterface.get_output_pressure","title":"<code>get_output_pressure()</code>  <code>abstractmethod</code>","text":"<p>Returns the output port pressure in mBar.</p> <p>Returns:</p> Type Description <p>Output Pressure</p> Source code in <code>src/pgva/pgva_interface.py</code> <pre><code>@abstractmethod\ndef get_output_pressure(self):\n    \"\"\"\n    Returns the output port pressure in mBar.\n\n    Returns:\n        Output Pressure\n    \"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/pgva/pgva_interface/#pgva.pgva_interface.PGVAInterface.get_pressure_chamber","title":"<code>get_pressure_chamber()</code>  <code>abstractmethod</code>","text":"<p>Returns the current reading of the pressure chamber in mBar.</p> <p>Returns:</p> Type Description <p>Chamber pressure</p> Source code in <code>src/pgva/pgva_interface.py</code> <pre><code>@abstractmethod\ndef get_pressure_chamber(self):\n    \"\"\"\n    Returns the current reading of the pressure chamber in mBar.\n\n    Returns:\n        Chamber pressure\n    \"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/pgva/pgva_interface/#pgva.pgva_interface.PGVAInterface.get_status_word","title":"<code>get_status_word()</code>  <code>abstractmethod</code>","text":"<p>Gets the status word from the PGVA.</p> <p>Returns:</p> Type Description <p>Status word: Dictionary of status</p> Source code in <code>src/pgva/pgva_interface.py</code> <pre><code>@abstractmethod\ndef get_status_word(self):\n    \"\"\"\n    Gets the status word from the PGVA.\n\n    Returns:\n        Status word: Dictionary of status\n    \"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/pgva/pgva_interface/#pgva.pgva_interface.PGVAInterface.get_vacuum_chamber","title":"<code>get_vacuum_chamber()</code>  <code>abstractmethod</code>","text":"<p>Returns the current reading of the vacuum chamber in mBar.</p> <p>Returns:</p> Type Description <p>Vacuum pressure</p> Source code in <code>src/pgva/pgva_interface.py</code> <pre><code>@abstractmethod\ndef get_vacuum_chamber(self):\n    \"\"\"\n    Returns the current reading of the vacuum chamber in mBar.\n\n    Returns:\n        Vacuum pressure\n    \"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/pgva/pgva_interface/#pgva.pgva_interface.PGVAInterface.get_warning_word","title":"<code>get_warning_word()</code>  <code>abstractmethod</code>","text":"<p>Gets the warning word from the PGVA-1.</p> <p>Returns:</p> Type Description <p>Warning word: Dictionary of warning word</p> Source code in <code>src/pgva/pgva_interface.py</code> <pre><code>@abstractmethod\ndef get_warning_word(self):\n    \"\"\"\n    Gets the warning word from the PGVA-1.\n\n    Returns:\n        Warning word: Dictionary of warning word\n    \"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/pgva/pgva_interface/#pgva.pgva_interface.PGVAInterface.set_output_pressure","title":"<code>set_output_pressure(pressure)</code>  <code>abstractmethod</code>","text":"<p>Abstract function for setting output pressure.</p> Source code in <code>src/pgva/pgva_interface.py</code> <pre><code>@abstractmethod\ndef set_output_pressure(self, pressure: int):\n    \"\"\"Abstract function for setting output pressure.\"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/pgva/pgva_interface/#pgva.pgva_interface.PGVAInterface.set_pressure_chamber","title":"<code>set_pressure_chamber(pressure)</code>  <code>abstractmethod</code>","text":"<p>Abstract function for setting internal pressure chamber.</p> Source code in <code>src/pgva/pgva_interface.py</code> <pre><code>@abstractmethod\ndef set_pressure_chamber(self, pressure: int):\n    \"\"\"Abstract function for setting internal pressure chamber.\"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/pgva/pgva_interface/#pgva.pgva_interface.PGVAInterface.set_vacuum_chamber","title":"<code>set_vacuum_chamber(vacuum)</code>  <code>abstractmethod</code>","text":"<p>Sets the internal vacuum chamber.</p> <p>Parameters:</p> Name Type Description Default <code>vacuum</code> <code>int</code> <p>mBar</p> required Source code in <code>src/pgva/pgva_interface.py</code> <pre><code>@abstractmethod\ndef set_vacuum_chamber(self, vacuum: int):\n    \"\"\"\n    Sets the internal vacuum chamber.\n\n    Args:\n        vacuum: mBar\n    \"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/pgva/pgva_interface/#pgva.pgva_interface.PGVAInterface.toggle_pump","title":"<code>toggle_pump(toggle)</code>  <code>abstractmethod</code>","text":"<p>Enable / Disables the pump.</p> <p>Parameters:</p> Name Type Description Default <code>toggle</code> <code>bool</code> <p>1 for on, 0 for off</p> required Source code in <code>src/pgva/pgva_interface.py</code> <pre><code>@abstractmethod\ndef toggle_pump(self, toggle: bool):\n    \"\"\"\n    Enable / Disables the pump.\n\n    Args:\n        toggle: 1 for on, 0 for off\n    \"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/pgva/pgva_interface/#pgva.pgva_interface.PGVAInterface.toggle_trigger","title":"<code>toggle_trigger(trigger)</code>  <code>abstractmethod</code>","text":"<p>Toggles the trigger.</p> <p>Parameters:</p> Name Type Description Default <code>trigger</code> <code>bool</code> <p>boolean value for on or off</p> required Source code in <code>src/pgva/pgva_interface.py</code> <pre><code>@abstractmethod\ndef toggle_trigger(self, trigger: bool):\n    \"\"\"\n    Toggles the trigger.\n\n    Args:\n        trigger: boolean value for on or off\n    \"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/pgva/pgva_interface/#pgva.pgva_interface.PGVAInterface.trigger_actuation_valve","title":"<code>trigger_actuation_valve(actuation_time)</code>  <code>abstractmethod</code>","text":"<p>Abstract function for running the actuation valve.</p> Source code in <code>src/pgva/pgva_interface.py</code> <pre><code>@abstractmethod\ndef trigger_actuation_valve(self, actuation_time: int):\n    \"\"\"Abstract function for running the actuation valve.\"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/pgva/registers/","title":"registers","text":"<p>Register mapping for PGVA.</p>"},{"location":"examples/examples/","title":"PGVA examples","text":"<p>Below will outline some examples of how to setup and run the PGVA along with basic function calls  </p>"},{"location":"examples/examples/#ethernet","title":"Ethernet","text":"<p>The examples listed below will be using the Ethernet port or [6] located in the diagram below. </p>"},{"location":"examples/examples/#hardware-setup","title":"Hardware Setup","text":"<p>In order to run the examples listed below, - A connection via ethernet cable must be made from the ethernet port of the PGVA to the host PC or device before the examples below can be run.  - Ensure that the host PC is connected to the PGVA via ethernet, either directly or via an intermediate networking device. - Connect the PGVA-1 via ethernet port to the host PC - For further documentation on how to setup the hardware, please reference the Festo Resources section of this page  </p>"},{"location":"examples/examples/#validating-setup","title":"Validating Setup","text":"<p>There are several ways to validate a correct Ethernet configuration and setup for connection to the PGVA-1 device below are two simple solutions. It is important to note that the PGVA-1 device will refuse a connection if the host PC or device's ethernet network range does not match that of the PGVA-1. </p>"},{"location":"examples/examples/#default-ip-address-range","title":"Default IP Address Range","text":"<p>Typically, the PGVA-1 ip address lies within a range of 192.168.0.1 -&gt; 192.168.0.100. This comes preprogammed within each device. To validate connection this way: 1. Validate that the host PC's ethernet port is on the same network range as 192.168.0.xxx 2. Use the Address Resolution protocol (arp) to display all connections on the PC <pre><code>arp -a \n</code></pre> 3. Ensure that the connection exists under the specified network ID range 4. Use <code>ping</code> to validate the PC can talk to the device <pre><code>ping 192.168.0.xxx\n</code></pre></p>"},{"location":"examples/examples/#using-festos-field-device-tool","title":"Using Festo's Field Device Tool","text":"<p>Festo offers a field device tool to scan for Festo devices connected to the host PC. 1. Download the Festo Field device tool 2. Using the Festo field device tool, scan for the device 3. Once device is found, configure host PC's ethernet port to the same network range as that of the PGVA-1 device</p>"},{"location":"examples/examples/#using-festos-automation-suite-application","title":"Using Festo's automation suite application'","text":"<p>Festo also offers an automation suite application that allows for complex configuration and control of Festo's wide variety of devices including the PGVA. For more information, please refer to the Festo Automation Suite page. 1. Download the Festo Automation Suite. 2. Using the Automation Suite find and configure the PGVA with the network range desired.  </p>"},{"location":"examples/examples/#using-festos-automation-suite-application_1","title":"Using Festo's Automation Suite Application","text":"<p>The Festo Automation Suite, a software application for device configuration and management, can also be used to read or configure the IP address and range of the device using the Device Scan view. To download the Festo Automation Suite, please visit here</p>"},{"location":"examples/examples/#coding-examples","title":"Coding Examples","text":"<p>The examples below provide basic implementations of the PGVA python driver and usage. </p>"},{"location":"examples/examples/#importing-the-pgva-driver-and-library","title":"Importing The PGVA Driver And Library","text":"<p>Before any examples that can be run, the PGVA-1 front end and tcp configuration needs to be defined first.</p>"},{"location":"examples/examples/#basic-startup","title":"Basic Startup","text":"<p>Example script of importing libaries into code space <pre><code>from pgva import PGVA, PGVATCPConfig\n\npgva_config = PGVATCPConfig(interface=\"tcp/ip\", unit_id=1, ip=\"192.168.0.1\", port=502)\n\npgva = PGVA(config=pgva_config)\n</code></pre></p>"},{"location":"examples/examples/#setting-output-pressure","title":"Setting Output Pressure","text":"<p>Example script to set output pressure on a PGVA instance. <pre><code>output_pressure_mbar = 100\npgva.set_output_pressure(output_pressure_mbar)\n\noutput_pressure_mbar_reading = pgva.get_output_pressure()\nprint(f\"Output Pressure set to: {output_pressure_mbar_reading} mbar\")\n</code></pre></p>"},{"location":"examples/examples/#setting-output-vacuum","title":"Setting Output Vacuum","text":"<p>Example script to set output vacuum on a PGVA instance. <pre><code>output_vacuum_mbar = -100\npgva.set_output_pressure(output_vacuum_mbar)\n\noutput_vacuum_mbar_reading = pgva.get_output_pressure()\nprint(f\"Output Vacuum set to: {output_vacuum_mbar_reading} mbar\")\n</code></pre></p>"},{"location":"examples/examples/#reading-internal-sensor-data","title":"Reading Internal Sensor Data","text":"<p>Read and print all internal sensor data. <pre><code>data = pgva.get_internal_sensor_data()\nprint(f\"Internal sensor data: {data}\")\n</code></pre></p>"},{"location":"examples/examples/#running-a-triggered-pressure-actuation-for-a-period-of-time","title":"Running A Triggered Pressure Actuation For A Period Of Time","text":"<p>Example script of how to run a timed pressure process. <pre><code>actuation_time_ms = 100\ntarget_pressure_mbar = 100\npgva.set_output_pressure(target_pressure_mbar)\npgva.trigger_actuation_valve(actuation_time_ms)\nprint(f\"Timed pressure set to {target_pressure_mbar} mbar for {actuation_time_ms} ms\")\n</code></pre></p>"},{"location":"examples/examples/#running-a-triggered-vacuum-actuation-for-a-period-of-time","title":"Running A Triggered Vacuum Actuation For A Period Of Time","text":"<p>Example script of how to run a timed vacuum process. <pre><code>actuation_time_ms = 100\ntarget_vacuum_mbar = -100\npgva.set_output_pressure(target_vacuum_mbar)\npgva.trigger_actuation_valve(actuation_time_ms)\n</code></pre></p>"},{"location":"examples/examples/#setting-internal-chambers-for-pressure-and-vacuum","title":"Setting Internal Chambers For Pressure And Vacuum","text":"<p>Example script to set internal pressure and vacuum chambers on a PGVA instance. <pre><code>internal_pressure_mbar = 200\npgva.set_pressure_chamber(internal_pressure_mbar)\n\ninternal_vacuum_mbar = -200\npgva.set_vacuum_chamber(internal_vacuum_mbar)\n</code></pre></p>"},{"location":"examples/examples/#printing-the-driver-information-of-the-pgva-python-driver","title":"Printing The Driver Information Of The PGVA Python Driver","text":"<p>Example script that prints the driver information. <pre><code>pgva.print_driver_information()\n</code></pre></p>"},{"location":"examples/examples/#running-the-code","title":"Running The Code","text":"<p>To run any of the following examples, navigate to the examples directory and follow the instructions below. Make sure to follow the section above for the setup instructions, a physical connection to the device must be made in order to run any driver code.</p>"},{"location":"examples/examples/#running-in-virtual-environment","title":"Running In Virtual Environment","text":"<ol> <li>Activate the virtual environment</li> <li>Run  <pre><code>python ./&lt;target_example_file&gt;.py\n</code></pre></li> </ol>"},{"location":"examples/examples/#running-with-uv","title":"Running With uv","text":"<p>Within your console enter the following command.  <pre><code>uv run &lt;target_example_file&gt;.py\n</code></pre></p>"}]}